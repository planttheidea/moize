<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"utils.js.html":{"id":"utils.js.html","title":"Source: utils.js","body":" moize Modules moize Global getArrayKey Source: utils.js // @flow // types import type {Expiration} from './types'; /** * @private * * @function combine * * @description * method to combine functions and return a single function that fires them all * * @param {...Array&lt;any&gt;} functions the functions to compose * @returns {function(...Array&lt;any&gt;): any} the composed function */ export const combine = (...functions: Array&lt;any&gt;): Function =&gt; { // $FlowIgnore return value is always a function return functions.reduce((f: Function, g: any): Function =&gt; { return typeof f === 'function' ? typeof g === 'function' ? function(): any { /* eslint-disable prefer-spread */ f.apply(this, arguments); g.apply(this, arguments); /* eslint-enable */ } : f : typeof g === 'function' ? g : function() {}; }); }; /** * @private * * @function compose * * @description * method to compose functions and return a single function * * @param {...Array&lt;any&gt;} functions the functions to compose * @returns {function(...Array&lt;any&gt;): any} the composed function */ export const compose = (...functions: Array&lt;any&gt;): Function =&gt; { // $FlowIgnore return value is always a function return functions.reduce((f: Function, g: any): Function =&gt; { return typeof f === 'function' ? typeof g === 'function' ? function(): any { return f(g.apply(this, arguments)); // eslint-disable-line prefer-spread } : f : typeof g === 'function' ? g : function(arg) { return arg; }; }); }; /** * @private * * @function findExpirationIndex * * @description * find the index of the expiration based on the key * * @param {Array&lt;Expiration&gt;} expirations the list of expirations * @param {Array&lt;any&gt;} key the key to match * @returns {number} the index of the expiration */ export const findExpirationIndex = (expirations: Array&lt;Expiration&gt;, key: Array&lt;any&gt;): number =&gt; { for (let index: number = 0; index &lt; expirations.length; index++) { if (expirations[index].key === key) { return index; } } return -1; }; /** * @private * * @function findKeyIndex * * @description * find the index of the key in the list of cache keys * * @param {function} isEqual the method to test equality * @param {Array&lt;Array&lt;any&gt;&gt;} keys the list of keys in cache * @param {Array&lt;any&gt;} key the key to match * @returns {number} the index of the key */ export const findKeyIndex = (isEqual: Function, keys: Array&lt;Array&lt;any&gt;&gt;, key: Array&lt;any&gt;): number =&gt; { cacheKeys: for (let keysIndex = 0; keysIndex &lt; keys.length; keysIndex++) { if (keys[keysIndex].length === key.length) { for (let keyIndex = 0; keyIndex &lt; key.length; keyIndex++) { if (!isEqual(key[keyIndex], keys[keysIndex][keyIndex])) { continue cacheKeys; } } return keysIndex; } } return -1; }; /** * @function getArrayKey * * @description * return the transformed key as an array * * @param {any} key the transformed key * @returns {Array&lt;any&gt;} the key as an array */ export const getArrayKey = (key: any): Array&lt;any&gt; =&gt; { return Array.isArray(key) ? key : [key]; }; × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" moize Modules moize Global getArrayKey Source: index.js // @flow // external dependencies import memoize from 'micro-memoize'; // constants import {DEFAULT_OPTIONS} from './constants'; // instance import {augmentMoizeInstance} from './instance'; // max age import {getMaxAgeOptions} from './maxAge'; // is equal import {getIsEqual, getTransformKey} from './options'; // stats import {collectStats, getDefaultProfileName, getStats, getStatsOptions, statsCache} from './stats'; // types import type {Expiration, MicroMemoizeOptions, Options} from './types'; // utils import {combine, compose} from './utils'; /** * @module moize */ export {collectStats}; /** * @function moize * * @description * memoize a function based its arguments passed, potentially improving runtime performance * * @example * import moize from 'moize'; * * // standard implementation * const fn = (foo, bar) =&gt; `${foo} ${bar}`; * const memoizedFn = moize(fn); * * // implementation with options * const fn = async (id) =&gt; get(`http://foo.com/${id}`); * const memoizedFn = moize(fn, {isPromise: true, maxSize: 5}); * * // implementation with convenience methods * const Foo = ({foo}) =&gt; &lt;div&gt;{foo}&lt;/div&gt;; * const MemoizedFoo = moize.react(Foo); * * @param {function|Options} fn the function to memoized, or a list of options when currying * @param {Options} [options=DEFAULT_OPTIONS] the options to apply * @returns {function} the memoized function */ function moize(fn: Function | Options, options: Options = DEFAULT_OPTIONS): Function { if (typeof fn === 'object') { return (curriedFn: Function | Options, curriedOptions: Options = {}) =&gt; { return typeof curriedFn === 'function' ? moize( curriedFn, // $FlowIgnore fn is actually an object of options Object.assign({}, fn, curriedOptions, { onCacheAdd: combine(curriedOptions.onCacheAdd, fn.onCacheAdd), onCacheChange: combine(curriedOptions.onCacheChange, fn.onCacheChange), onCacheHit: combine(curriedOptions.onCacheHit, fn.onCacheHit) }) ) : moize( // $FlowIgnore fn is actually an object of options Object.assign({}, fn, curriedFn, { onCacheAdd: combine(curriedFn.onCacheAdd, fn.onCacheAdd), onCacheChange: combine(curriedFn.onCacheChange, fn.onCacheChange), onCacheHit: combine(curriedFn.onCacheHit, fn.onCacheHit) }) ); }; } const coalescedOptions: Options = Object.assign({}, DEFAULT_OPTIONS, options, { profileName: options.profileName || getDefaultProfileName(fn) }); const expirations: Array&lt;Expiration&gt; = []; const { equals: equalsIgnored, isPromise, isReact: isReactIgnored, isSerialized: isSerialzedIgnored, maxAge: maxAgeIgnored, maxArgs: maxArgsIgnored, maxSize, onCacheAdd: onCacheAddIgnored, onCacheChange, onCacheHit: onCacheHitIgnored, onExpire: onExpireIgnored, profileName: profileNameIgnored, shouldSerializeFunctions: shouldSerializeFunctionsIgnored, serializer: serializerIgnored, transformArgs: transformArgsIgnored, updateExpire: updateExpireIgnored, ...customOptions } = coalescedOptions; const isEqual: Function = getIsEqual(coalescedOptions); const maxAgeOptions: Options = getMaxAgeOptions(expirations, coalescedOptions, isEqual); const statsOptions: Options = getStatsOptions(coalescedOptions); const transformKey: ?Function = getTransformKey(coalescedOptions); const microMemoizeOptions: MicroMemoizeOptions = Object.assign({}, customOptions, { isEqual, isPromise, maxSize, onCacheAdd: combine(maxAgeOptions.onCacheAdd, statsOptions.onCacheAdd), onCacheChange, onCacheHit: combine(maxAgeOptions.onCacheHit, statsOptions.onCacheHit), transformKey }); return augmentMoizeInstance(memoize(fn, microMemoizeOptions), { expirations, options: coalescedOptions, originalFunction: fn }); } /** * @function compose * @name isCollectingStats * @memberof module:moize * @alias moize.compose * * @description * method to compose moized methods and return a single moized function * * @param {...Array&lt;(function)&gt;} functions the functions to compose * @returns {function(...Array&lt;*&gt;): *} the composed function */ moize.compose = compose; /** * @function * @name deep * @memberof module:moize * @alias moize.deep * * @description * should deep equality check be used * * @returns {function} the moizer function */ moize.deep = moize({isDeepEqual: true}); /** * @function * @name getStats * @memberof module:moize * @alias moize.getStats * * @description * get the statistics of a given profile, or overall usage * * @returns {StatsProfile} statistics for a given profile or overall usage */ moize.getStats = getStats; /** * @function * @name isCollectingStats * @memberof module:moize * @alias moize.isCollectingStats * * @description * are stats being collected * * @returns {boolean} are stats being collected */ moize.isCollectingStats = (): boolean =&gt; { return statsCache.isCollectingStats; }; /** * @function * @name isMoized * @memberof module:moize * @alias moize.isMoized * * @description * is the fn passed a moized function * * @param {*} fn the object to test * @returns {boolean} is fn a moized function */ moize.isMoized = (fn: any): boolean =&gt; { return typeof fn === 'function' &amp;&amp; fn.isMoized; }; /** * @function * @name maxAge * @memberof module:moize * @alias moize.maxAge * * @description * a moized method where the age of the cache is limited to the number of milliseconds passed * * @param {number} maxAge the TTL of the value in cache * @returns {function} the moizer function */ moize.maxAge = (maxAge: number): Function =&gt; { return moize({maxAge}); }; /** * @function * @name maxArgs * @memberof module:moize * @alias moize.maxArgs * * @description * a moized method where the number of arguments used for determining cache is limited to the value passed * * @param {number} maxArgs the number of args to base the key on * @returns {function} the moizer function */ moize.maxArgs = (maxArgs: number): Function =&gt; { return moize({maxArgs}); }; /** * @function * @name maxSize * @memberof module:moize * @alias moize.maxSize * * @description * a moized method where the total size of the cache is limited to the value passed * * @param {number} maxSize the maximum size of the cache * @returns {function} the moizer function */ moize.maxSize = (maxSize: number): Function =&gt; { return moize({maxSize}); }; /** * @function * @name promise * @memberof module:moize * @alias moize.promise * * @description * a moized method specific to caching resolved promise / async values * * @returns {function} the moizer function */ moize.promise = moize({isPromise: true}); /** * @function * @name react * @memberof module:moize * @alias moize.react * * @description * a moized method specific to caching React element values * * @returns {function} the moizer function */ moize.react = moize({isReact: true}); /** * @function * @name reactSimple * @memberof module:moize * @alias moize.reactSimple * * @description * a moized method specific to caching React element values, limiting to only the most recent result * * @returns {function} the moizer function */ moize.reactSimple = moize({isReact: true, maxSize: 1}); /** * @function * @name serialize * @memberof module:moize * @alias moize.serialize * * @description * a moized method that will serialize the arguments passed to use as the cache key * * @returns {function} the moizer function */ moize.serialize = moize({isSerialized: true}); /** * @function * @name simple * @memberof module:moize * @alias moize.simple * * @description * a moized method that will limit the cache values to only the most recent result * * @returns {function} the moizer function */ moize.simple = moize.maxSize(1); export default moize; × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"global.html":{"id":"global.html","title":"Global","body":" moize Modules moize Global getArrayKey Global Methods getArrayKey(key) return the transformed key as an array Parameters: Name Type Description key any the transformed key Source: utils.js, line 112 Returns: the key as an array Type Array.&lt;any&gt; × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" moize Modules moize Global getArrayKey Modules × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" moize Modules moize Global getArrayKey moize 4.0.4 moize moize is a blazing fast memoization library for JavaScript. It handles multiple parameters (including default values) without any additional configuration, and offers options to help satisfy a number of implementation-specific needs. It has no dependencies, and is ~3.2kb when minified and gzipped. Table of contents Installation Usage Advanced usage equals isPromise isReact maxAge maxArgs maxSize onExpire promiseLibrary serialize serializeFunctions serializer transformArgs updateExpire Usage with shortcut methods moize.maxAge moize.maxArgs moize.maxSize moize.promise moize.react moize.reactSimple moize.serialize moize.simple Composition Introspection isMoized Benchmarks Single parameter Multiple parameters (primitives only) Multiple parameters (complex objects) Direct cache manipulation add clear has keys remove values Browser support Development Installation $ npm i moize --saveUsage import moize from &quot;moize&quot;; const method = (a, b) =&gt; { return a + b; }; const memoized = moize(method); memoized(2, 4); // 6 memoized(2, 4); // 6, pulled from cacheAll parameter types are supported, including circular objects, functions, etc. There are also a number of shortcut methods to memoize for unique use-cases with ease. Advanced usage moize optionally accepts an object of options as either the second parameter or as the first step in a curried function: // inline moize(fn, options); // curried moize(options)(fn);The full shape of these options: { equals: Function, // custom method to compare equality between two objects isDeepEqual: boolean, // is the cache based on deep equality of keys isPromise: boolean, // is the result a promise isReact: boolean, // is the result a React component isSerialized: boolean, // should the parameters be serialized instead of directly referenced maxAge: number, // amount of time in milliseconds before the cache will expire maxArgs: number, // maximum number of arguments to use as key for caching maxSize: number, // maximum size of cache for this method profileName: string, // the unique identifier to give the memoized method when collecting statistics shouldSerializeFunctions: boolean, // should functions be included in the serialization of multiple parameters serializer: Function // method to serialize the arguments to build a unique cache key }equals defaults to strict equality Custom method used to compare equality of keys for cache purposes. // using fast-equals's deep equal comparison method import { deepEqual } from &quot;fast-equals&quot;; const fn = ({ foo, bar }) =&gt; { return [foo, bar]; }; const memoized = moize(fn, { equals: deepEqual }); memoized({ foo: &quot;foo&quot;, bar: &quot;bar&quot; }); memoized({ foo: &quot;foo&quot;, bar: &quot;bar&quot; }); // pulls from cacheThe equals method receives two parameters (cache key values) and should return a boolean. Please note that this will be slower than the default strict equality comparison, however how much slower is based on the efficiency of the method passed. isPromise defaults to false Is the computed value in the function a Promise, and should we cache the resolved value from that Promise. This is also available via the shortcut method of moize.promise. const fn = async item =&gt; { return await item; }; const memoized = moize(fn, { isPromise: true });The resolved value of the Promise will be stored in cache as a Promise itself, so that cached returns will always be in the form of a Promise. For common usage reasons, if the Promise is rejected, the cache entry will be deleted. Also, if a maxAge is provided, the countdown of that TTL will begin upon the resolution of the promise rather than at the instantiation of it. isReact defaults to false Is the function passed a stateless functional React component. This is also available via the shortcut method of moize.react. const Foo = ({ bar, baz }) =&gt; { return ( &lt;div&gt; {bar}: {baz} &lt;/div&gt; ); }; export default moize(Foo, { isReact: true });The method will do a shallow comparison of both props and context of the component based on strict equality. If you have mutative props and instead want to do a deep equals comparison, provide a custom equals option. maxAge defaults to Infinity The maximum amount of time in milliseconds that you want a computed value to be stored in cache for this method. This is also available via the shortcut method of moize.maxAge. const fn = item =&gt; { return item; }; const memoized = moize(fn, { maxAge: 1000 * 60 * 5 // five minutes });maxArgs defaults to the length of arguments passed to the method The maximum number of arguments used in creating the key for the cache. This is also available via the shortcut method of moize.maxArgs. const fn = (item1, item2, item3) =&gt; { return item1 + item2 + item3; }; const memoized = moize(fn, { maxArgs: 2 }); memoize(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;); memoize(&quot;foo&quot;, &quot;bar&quot;, &quot;quz&quot;); // pulls from cache, as the first two args are the samePlease note that if maxArgs is combined with either serialize or transformArgs, the following order is used: limit by maxArgs transform by transformArgs (if applicable) serialize by serializer (if applicable) maxSize defaults to Infinity The maximum number of values you want stored in cache for this method. Clearance of the cache once the maxSize is reached is on a Least Recently Used basis. This is also available via the shortcut method of moize.maxSize. const fn = item =&gt; { return item; }; const memoized = moize(fn, { maxSize: 5 });onExpire A callback that is called when one of cache item expires. Note that maxAge must also be set because by default keys never expire. const fn = item =&gt; { return item; }; const memoized = moize(fn, { maxAge: 10000, onExpire(key) { console.log(key); } });If you return false from this method, it will prevent the key's removal, instead refreshing the expiration in the same vein as updateExpire based on maxAge: const fn = item =&gt; { return item; }; let expirationAttempts = 0; const memoized = moize(fn, { maxAge: 1000 * 10, // 10 seconds onExpire(key) { expirationAttempts++; return expirationAttempts &lt; 2; } }); memoized(&quot;foo&quot;); // will expire key after 30 seconds, or 3 expiration attemptspromiseLibrary defaults to native Promise The promise library to use for resolution / rejection of promises. const fn = foo =&gt; { return new Bluebird(resolve =&gt; { resolve(foo); }); }; const memoized = moize(fn, { isPromise: true, promiseLibrary: Bluebird });Please note that for this option to work isPromise must be set to true. You can use any library where the following aspects of the specification are included: It is thenable (the generated promise has a .then() function) The Promise object itself has .resolve() and .reject() functions on it Most modern libraries (bluebird, q, etc.) include these by default, however if you are using a custom library that does not meet these requirements then you will need to implement them yourself. An example of a wrapper that creates the .resolve() and .reject() methods: import foo from &quot;my-promise-library&quot;; // create a wrapper so as not to touch the library itself const customPromise = fn =&gt; { return foo(fn); }; // lets pretend foo has a .result() method that has the first // parameter as successful, second as failure customPromise.resolve = function(value) { return foo.result(value); }; customPromise.reject = function(error) { return foo.result(undefined, error); }; const fn = foo =&gt; { return customPromise(resolve =&gt; { resolve(foo); }); }; const memoized = moize(fn, { isPromise: true, promiseLibrary: customPromise });serialize defaults to false Serializes the parameters passed into a string and uses this as the key for cache comparison. This is also available via the shortcut method of moize.serialize. const fn = mutableObject =&gt; { return mutableObject.foo; }; const memoized = moize(fn, { serialize: true }); const object = { foo: &quot;foo&quot; }; memoized(object); // 'foo' object.foo = &quot;bar&quot;; memoized(object); // 'bar'Please note that this is slower than the default key storage (see benchmarks). Also note that if serialize is combined with either maxArgs or transformArgs, the following order is used: limit by maxArgs (if applicable) transform by transformArgs (if applicable) serialize by serializer serializeFunctions defaults to false A custom replacer is used when serializing to ensure functions are included in the key serialization. const FunctionalComponent = ({ onClickFoo }) =&gt; { return ( &lt;button onClick={onClickFoo} type=&quot;button&quot;&gt; Click me! &lt;/button&gt; ); }; const MemoizedFunctionalComponent = moize(FunctionalComponent, { serialize: true, serializeFunctions: true });Please note that you must also set serialize to true for this setting to take effect. serializer defaults to serializeArguments in utils.js Overrides the internal serializer when serializing the parameters for cache key comparison. The value returned from the function must be a valid value of keys for a Map; it does not need to a string, but should be unique from a strict equality perspective. const serializer = args =&gt; { return JSON.stringify(args[0]); }; const memoized = moize(fn, { serialize: true, serializer });Please note that you must also set serialize to true for this setting to take effect. transformArgs Transform the arguments passed before it is used as a key. The function accepts a single argument, the Array of args, and must also return an Array. const fn = (one, two, three) =&gt; { return [two, three]; }; const ignoreFirstArg = args =&gt; { return args.slice(1); }; const moized = moize(fn, { transformArgs: ignoreFirstArg }); moize(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;); moize(null, &quot;bar&quot;, &quot;baz&quot;); // pulled from cachePlease note that if transformArgs is combined with either maxArgs or serialize, the following order is used: limit by maxArgs (if applicable) transform by transformArgs serialize by serializer (if applicable) updateExpire When a maxAge is set, clear out the scheduled expiration of the key whenever that key is retrieved, updating the new expiration to be based on the last retrieval from cache. const fn = item =&gt; { return item; }; const memoized = moize(fn, { maxAge: 1000 * 60 * 5, // five minutes updateExpire: true }); memoized(&quot;foo&quot;); setTimeout(() =&gt; { memoized(&quot;foo&quot;); // hits cache, which updates the expire to be 5 minutes from this run instead of the first }, 1000 * 60);Usage with shortcut methods moize.maxAge Pre-applies the maxAge option as a curriable method. import moize from &quot;moize&quot;; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.maxAge(5000)(foo);moize.maxArgs Pre-applies the maxArgs option as a curriable method. import moize from &quot;moize&quot;; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.maxArgs(1)(foo);moize.maxSize Pre-applies the maxSize option as a curriable method. import moize from &quot;moize&quot;; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.maxSize(5)(foo);moize.promise Pre-applies the isPromise option. import moize from &quot;moize&quot;; const foo = async (bar, baz) =&gt; { return await someApiCall(bar, baz); }; export default moize.promise(foo);Please note that if you want to provide a custom promiseLibrary, you must do so with additional options: const additionalOptions = { promiseLibrary: Bluebird }; moize.promise(fn, additionalOptions); // or moize.promise(additionalOptions)(fn);moize.react Shortcut for memoizing functional components in React. This uses a special cache key that will do a shallow equal comparison of changes to both props and context. import moize from &quot;moize&quot;; const Foo = ({ bar, baz }) =&gt; { return ( &lt;div&gt; {bar} {baz} &lt;/div&gt; ); }; export default moize.react(Foo);Also, it should be noted that in usages that involve a lot of variety in the parameter changes, this has the potential for excessive memory consumption, as the cache will retain the history of all elements. It is therefore recommended to apply a maxSize, or to use the shortcut method moize.reactSimple, which automatically sets the maxSize to 1. Please note moize.react will not operate with components made via the class instantiation, as they do not offer the same referential transparency. moize.reactSimple Shortcut for memoizing functional components in React, with the cache size limited to a single entry. This mimics the PureComponent optimization, where the cache will only contain the component with the most recent props and context combination. import moize from &quot;moize&quot;; const Foo = ({ bar, baz }) =&gt; { return ( &lt;div&gt; {bar} {baz} &lt;/div&gt; ); }; export default moize.reactSimple(Foo);Please note moize.reactSimple will not operate with components made via the class instantiation, as they do not offer the same referential transparency. moize.serialize Pre-applies the serialize option. import moize from &quot;moize&quot;; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.serialize(foo);Please note that if you want to serializeFunctions or provide a custom serializer, you must do so with additional options: const additionalOptions = { serializeFunctions: true }; moize.serialize(fn, additionalOptions); // or moize.serialize(additionalOptions)(fn);moize.simple Pre-applies the maxSize option with 1. import moize from &quot;moize&quot;; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.simple(foo);Composition Starting with version 2.3.0, you can compose moize methods. This will create a new memoized method with the original function that shallowly merges the options of the two setups. Example: import moize from &quot;moize&quot;; const Foo = props =&gt; { return &lt;div {...props} /&gt;; }; // memoizing with react, as since 2.0.0 const MemoizedFoo = moize.react(Foo); // creating a separately-memoized method that has maxSize of 5 const LastFiveFoo = moize.maxSize(5)(MemoizedFoo);You can also create an options-first curriable version of moize if you only pass the options: import moize from &quot;moize&quot;; // creates a function that will memoize what is passed const limitedSerializedMoize = moize({ maxSize: 5, serialize: true }); const foo = bird =&gt; { return `${bird} is the word`; }; const moizedFoo = limitedSerializedMoize(foo);You can also combine all of these options with moize.compose to create moize wrappers with pre-defined options. import moize from &quot;moize&quot;; // creates a moizer that will have the options of // {isReact: true, maxAge: 5000, maxSize: 5} const superLimitedReactMoize = moize.compose( moize.react, moize.maxSize(5), moize.maxAge(5000) );Introspection There currently is only one method to introspect objects specific to moize, but if you want more just ask! isMoized Is the function passed a moized function. const fn = () =&gt; {}; const moizedFn = moize(fn); moize.isMoized(fn); // false moize.isMoized(moizedFn); // trueBenchmarks All values provided are the number of operations per second (ops/sec) calculated by the Benchmark suite. Note that underscore, lodash, and ramda do not support mulitple-parameter memoization, so they are not included in those benchmarks. Each benchmark was performed using the default configuration of the library, with a fibonacci calculation based on a starting parameter of 35, using single and multiple parameters with different object types. The results were averaged to determine overall speed across all scenarios. Name Overall (average) Single (average) Multiple (average) Single (primitive) Single (Array) Single (Object) Multiple (primitive) Multiple (Array) Multiple (Object) moize 58,669,248 67,308,143 50,030,353 80,260,036 60,871,531 60,792,864 50,510,487 50,281,433 49,299,140 fast-memoize 37,901,525 74,753,514 1,049,536 221,161,329 1,594,143 1,505,072 1,215,892 1,111,605 821,111 memoizee 11,128,750 13,712,714 8,544,786 16,811,901 11,983,924 12,342,317 10,568,148 7,401,170 7,665,041 lru-memoize 7,042,509 7,492,004 6,593,015 8,189,054 7,153,791 7,133,169 6,675,840 6,592,401 6,510,804 memoizerific 4,484,511 4,840,758 4,128,264 5,641,865 4,418,423 4,461,986 4,761,211 3,998,986 3,624,597 addy-osmani 2,730,139 3,381,737 2,078,540 6,580,745 1,784,218 1,780,250 3,478,684 1,786,383 970,555 lodash N/A 14,825,854 N/A 27,985,602 8,207,788 8,284,173 N/A N/A N/A underscore N/A 12,505,751 N/A 24,051,104 5,404,896 8,061,254 N/A N/A N/A ramda N/A 551,402 N/A 1,142,370 303,464 208,372 N/A N/A N/A Direct cache manipulation There are a few methods provided on the moized function which allow for programmatic manipulation of the cache: add(key, value) This will manually add the value at key in cache if key does not already exist. key is an Array of values, meant to reflect the arguments passed to the method. // single parameter is straightforward const memoized = moize(item =&gt; { return item; }); memoized.add([&quot;foo&quot;], &quot;bar&quot;); // pulls from cache memoized(&quot;foo&quot;);clear() This will clear all values in the cache, resetting it to an empty state. const memoized = moize(item =&gt; { return item; }); memoized.clear();has(key) This will return true if a cache entry exists for the key passed, else will return false. key is an Array of values, meant to reflect the arguments passed to the method. const memoized = moize((first, second) =&gt; { return [first, second]; }); memoized(&quot;foo&quot;, &quot;bar&quot;); console.log(memoized.has([&quot;foo&quot;, &quot;bar&quot;])); // true console.log(memoized.has([&quot;bar&quot;, &quot;baz&quot;])); // falsekeys() This will return a list of the current keys in cache. const memoized = moize(item =&gt; { return item; }); const foo = &quot;foo&quot;; memoized(foo); const bar = { baz: &quot;baz&quot; }; memoized(bar); const keys = memoized.keys(); // ['foo', {baz: 'baz'}]remove(key) This will remove the provided key from cache. key is an Array of values, meant to reflect the arguments passed to the method. const memoized = moize(item =&gt; { return item; }); const foo = { bar: &quot;baz&quot; }; memoized(foo); memoized.remove([foo]); // will re-execute, as it is no longer in cache memoized(foo);values() This will return a list of the current values in cache when the native Cache. const memoized = moize(item =&gt; { return { item }; }); const foo = &quot;foo&quot;; memoized(foo);moize.min.js const bar = { baz: &quot;baz&quot; }; memoized(bar); const values = memoized.values(); // [{item: 'foo'}, {item: {baz: 'baz'}}]Browser support Chrome (all versions) Firefox (all versions) Edge (all versions) Opera 15+ IE 9+ Safari 6+ iOS 8+ Android 4+ Development Standard stuff, clone the repo and npm install dependencies. The npm scripts available: build =&gt; run webpack to build development dist file with NODE_ENV=development build:minifed =&gt; run webpack to build production dist file with NODE_ENV=production dev =&gt; run webpack dev server to run example app (playground!) dist =&gt; runs build and build-minified docs =&gt; builds the docs via jsdoc lint =&gt; run ESLint against all files in the src folder prepublish =&gt; runs compile-for-publish prepublish:compile =&gt; run lint, test, transpile:es, transpile:lib, dist test =&gt; run AVA test functions with NODE_ENV=test test:coverage =&gt; run test but with nyc for coverage checker test:watch =&gt; run test, but with persistent watcher transpile:lib =&gt; run babel against all files in src to create files in lib transpile:es =&gt; run babel against all files in src to create files in es, preserving ES2015 modules (for pkg.module) × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"module-moize.html":{"id":"module-moize.html","title":"Module: moize","body":" moize Modules moize Global getArrayKey Module: moize Source: index.js, line 27 Methods &lt;inner&gt; deep() should deep equality check be used Source: index.js, line 143 Returns: the moizer function Type function &lt;inner&gt; getStats() get the statistics of a given profile, or overall usage Source: index.js, line 156 Returns: statistics for a given profile or overall usage Type StatsProfile &lt;inner&gt; isCollectingStats(functions) method to compose moized methods and return a single moized function Parameters: Name Type Argument Description functions Array.&lt;(function())&gt; &lt;repeatable&gt; the functions to compose Source: index.js, line 129 Returns: the composed function Type function &lt;inner&gt; isCollectingStats() are stats being collected Source: index.js, line 169 Returns: are stats being collected Type boolean &lt;inner&gt; isMoized(fn) is the fn passed a moized function Parameters: Name Type Description fn * the object to test Source: index.js, line 184 Returns: is fn a moized function Type boolean &lt;inner&gt; maxAge(maxAge) a moized method where the age of the cache is limited to the number of milliseconds passed Parameters: Name Type Description maxAge number the TTL of the value in cache Source: index.js, line 200 Returns: the moizer function Type function &lt;inner&gt; maxArgs(maxArgs) a moized method where the number of arguments used for determining cache is limited to the value passed Parameters: Name Type Description maxArgs number the number of args to base the key on Source: index.js, line 216 Returns: the moizer function Type function &lt;inner&gt; maxSize(maxSize) a moized method where the total size of the cache is limited to the value passed Parameters: Name Type Description maxSize number the maximum size of the cache Source: index.js, line 232 Returns: the moizer function Type function &lt;inner&gt; moize(fn [, options]) memoize a function based its arguments passed, potentially improving runtime performance Parameters: Name Type Argument Default Description fn function | Options the function to memoized, or a list of options when currying options Options &lt;optional&gt; DEFAULT_OPTIONS the options to apply Source: index.js, line 33 Returns: the memoized function Type function Example import moize from 'moize'; // standard implementation const fn = (foo, bar) =&gt; `${foo} ${bar}`; const memoizedFn = moize(fn); // implementation with options const fn = async (id) =&gt; get(`http://foo.com/${id}`); const memoizedFn = moize(fn, {isPromise: true, maxSize: 5}); // implementation with convenience methods const Foo = ({foo}) =&gt; &lt;div&gt;{foo}&lt;/div&gt;; const MemoizedFoo = moize.react(Foo); &lt;inner&gt; promise() a moized method specific to caching resolved promise / async values Source: index.js, line 248 Returns: the moizer function Type function &lt;inner&gt; react() a moized method specific to caching React element values Source: index.js, line 261 Returns: the moizer function Type function &lt;inner&gt; reactSimple() a moized method specific to caching React element values, limiting to only the most recent result Source: index.js, line 274 Returns: the moizer function Type function &lt;inner&gt; serialize() a moized method that will serialize the arguments passed to use as the cache key Source: index.js, line 287 Returns: the moizer function Type function &lt;inner&gt; simple() a moized method that will limit the cache values to only the most recent result Source: index.js, line 300 Returns: the moizer function Type function × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
