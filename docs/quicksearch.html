<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"Cache.js.html":{"id":"Cache.js.html","title":"Source: Cache.js","body":" moize Modules moize Source: Cache.js // @flow // types import type {ExpirationItem, ListItem, Options} from './types'; // utils import {findIndex, findIndexAfterFirst, isFunction, splice, unshift} from './utils'; /** * @private * * @class Cache * * @classdesc * class that is similar to the Map infrastructure, but faster and * more targeted to moize use cases */ class Cache { constructor(options: Options) { this.options = options; } expirations: Array&lt;ExpirationItem&gt; = []; lastItem: ListItem = {}; list: Array&lt;ListItem&gt; = []; options: Options; size: number = 0; /** * @function add * @memberof Cache * @instance * * @description * add a new item to cache * * @param {*} key the key to assign * @param {*} value the value to assign at key */ add(key: any, value: any): any { this.lastItem = unshift(this.list, { key, value }); this.size++; } /** * @function clear * @memberof Cache * @instance * * @description * clear the cache of all items */ clear() { this.lastItem = {}; this.list.length = this.size = 0; } /** * @function expireAfter * @memberof Cache * @instance * * @description * remove from cache after maxAge time has passed * * @param {*} key the key to remove */ expireAfter(key: any) { const {maxAge, onExpire} = this.options; const timeoutId = setTimeout(() =&gt; { const index: number = findIndex(this.list, key); if (~index) { const value: any = this.list[index]; this.remove(key); this.expirations.splice(findIndex(this.expirations, key), 1); // $FlowIgnore onExpire will only fire if it is a function if (isFunction(onExpire) &amp;&amp; onExpire(key.key) === false) { this.add(key, value); return this.expireAfter(key); } } }, maxAge); const indexOfKey = findIndex(this.expirations, key); if (~indexOfKey) { clearTimeout(this.expirations[indexOfKey].timeoutId); this.expirations[indexOfKey].timeoutId = timeoutId; } else { this.expirations.push({key, timeoutId}); } } /** * @function get * @memberof Cache * @instance * * @description * get the value of an item from cache if it exists * * @param {*} key the key to get the value of * @returns {*} the value at key */ get(key: any): any { if (this.size) { if (key === this.lastItem.key) { if (this.options.updateExpire) { this.expireAfter(key); } return this.lastItem.value; } const index: number = findIndexAfterFirst(this.list, key); if (~index) { if (this.options.updateExpire) { this.expireAfter(key); } this.lastItem = this.list[index]; return unshift(splice(this.list, index), this.lastItem).value; } } } /** * @private * * @function has * * @description * does the key exist in the cache * * @param {*} key the key to find in cache * @returns {boolean} does the key exist in cache */ has(key: any): boolean { return this.size !== 0 &amp;&amp; (key === this.lastItem.key || !!~findIndexAfterFirst(this.list, key)); } /**= * @function remove * @memberof Cache * @instance * * @description * remove the item at key from cach * * @param {*} key the key to remove from cache * @returns {void} */ remove(key: any) { const index: number = findIndex(this.list, key); if (~index) { splice(this.list, index); if (this.size === 1) { return this.clear(); } this.size--; if (!index) { this.lastItem = this.list[0]; } } } /** * @function update * @memberof Cache * @instance * * @description * update an item in-place with a new value * * @param {*} key key to update value of * @param {*} value value to store in the map at key */ update(key: any, value: any) { const index: number = findIndex(this.list, key); if (~index) { this.list[index].value = value; if (this.lastItem &amp;&amp; key === this.lastItem.key) { this.lastItem.value = value; } } } } export default Cache; × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" moize Modules moize Source: index.js // @flow // cache import Cache from './Cache'; // constants import {INVALID_FIRST_PARAMETER_ERROR} from './constants'; // types import type {Options} from './types'; // utils import { compose, createAddPropertiesToFunction, createCurriableOptionMethod, createGetCacheKey, createSetNewCachedValue, getDefaultedOptions, isFunction, isPlainObject } from './utils'; /** * @module moize */ /** * @function moize * * @description * store cached values returned from calling method with arguments to avoid reprocessing data from same arguments * * @example * import moize from 'moize'; * * // standard implementation * const fn = (foo, bar) =&gt; { * return `${foo} ${bar}`; * }; * const memoizedFn = moize(fn); * * // implementation with options * const fn = async (id) =&gt; { * return get(`http://foo.com/${id}`); * }; * const memoizedFn = moize(fn, { * isPromise: true, * maxSize: 5 * }); * * @param {function} functionOrComposableOptions method to memoize * @param {Options} [passedOptions={}] options to customize how the caching is handled * @param {boolean} [passedOptions.isPromise=false] is the function return expected to be a promise to resolve * @param {number} [passedOptions.maxAge=Infinity] the maximum age the value should persist in cache * @param {number} [passedOptions.maxArgs=Infinity] the maximum number of arguments to be used in serializing the keys * @param {number} [passedOptions.maxSize=Infinity] the maximum size of the cache to retain * @param {function} [passedOptions.promiseLibrary=Promise] promise library to use for resolution / rejection * @param {function} [passedOptions.serializeFunctions=false] should function parameters be serialized as well * @param {function} [passedOptions.serializer] method to serialize arguments with for cache storage * @returns {Function} higher-order function which either returns from cache or newly-computed value */ const moize: Function = (functionOrComposableOptions: Function | Object, passedOptions: Object = {}): Function =&gt; { if (isPlainObject(functionOrComposableOptions)) { return function(fnOrOptions: Function | Object, otherOptions: Object = {}): Function { if (isPlainObject(fnOrOptions)) { return moize({ // $FlowIgnore functionOrComposableOptions is object of options ...functionOrComposableOptions, // $FlowIgnore fnOrOptions is object of options ...fnOrOptions }); } return moize(fnOrOptions, { // $FlowIgnore functionOrComposableOptions is object of options ...functionOrComposableOptions, ...otherOptions }); }; } if (!isFunction(functionOrComposableOptions)) { throw new TypeError(INVALID_FIRST_PARAMETER_ERROR); } const isComposed: boolean = functionOrComposableOptions.isMoized; // $FlowIgnore if the function is already moized, it has an originalFunction property on it const fn: Function = isComposed ? functionOrComposableOptions.originalFunction : functionOrComposableOptions; const options: Options = getDefaultedOptions( isComposed ? { ...functionOrComposableOptions.options, ...passedOptions } : passedOptions ); const cache: Cache = new Cache(options); const addPropertiesToFunction: Function = createAddPropertiesToFunction(cache, fn, options); const getCacheKey: Function = createGetCacheKey(cache, options); const setNewCachedValue: Function = createSetNewCachedValue(cache, options); return addPropertiesToFunction(function(...args: Array&lt;any&gt;): any { const key: any = getCacheKey(args); return cache.size &amp;&amp; cache.has(key) ? cache.get(key) : setNewCachedValue(key, fn.apply(this, args)); }); }; /** * @function isMoized * * @description * is the fn passed a moized function * * @param {*} fn the object to test * @returns {boolean} is fn a moized function */ moize.isMoized = (fn: any): boolean =&gt; { return isFunction(fn) &amp;&amp; !!fn.isMoized; }; /** * @function compose * * @description * method to compose moized methods and return a single moized function * * @param {...Array&lt;(function)&gt;} functions the functions to compose * @returns {function(...Array&lt;*&gt;): *} the composed function */ moize.compose = compose; /** * @function maxAge * * @description * a moized method where the age of the cache is limited to the number of milliseconds passed * * @param {...Array&lt;*&gt;} functions the functions to compose * @returns {*} the moized function */ moize.maxAge = createCurriableOptionMethod(moize, 'maxAge'); /** * @function maxArgs * * @description * a moized method where the number of arguments used for determining cache is limited to the value passed * * @param {...Array&lt;*&gt;} functions the functions to compose * @returns {*} the moized function */ moize.maxArgs = createCurriableOptionMethod(moize, 'maxArgs'); /** * @function maxSize * * @description * a moized method where the total size of the cache is limited to the value passed * * @param {...Array&lt;*&gt;} functions the functions to compose * @returns {*} the moized function */ moize.maxSize = createCurriableOptionMethod(moize, 'maxSize'); /** * @function promise * * @description * a moized method specific to caching resolved promise / async values * * @param {...Array&lt;*&gt;} functions the functions to compose * @returns {*} the moized function */ moize.promise = moize({ isPromise: true }); /** * @function react * * @description * a moized method specific to caching React components * * @param {...Array&lt;*&gt;} functions the functions to compose * @returns {*} the moized function */ moize.react = moize({ isReact: true }); /** * @function reactSimple * * @description * a moized method specific to caching React components, only keeping the most recently-cached version * * @param {...Array&lt;*&gt;} functions the functions to compose * @returns {*} the moized function */ moize.reactSimple = compose(moize.react, moize.maxSize(1)); /** * @function serialize * * @description * a moized method where the arguments passed are cached based on their serialized values * * @param {...Array&lt;*&gt;} functions the functions to compose * @returns {*} the moized function */ moize.serialize = moize({ serialize: true }); /** * @function simple * * @description * a moized method where only the most recent key =&gt; value combination is cached * * @param {...Array&lt;*&gt;} functions the functions to compose * @returns {*} the moized function */ moize.simple = moize.maxSize(1); export default moize; × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"ReactCacheKey.js.html":{"id":"ReactCacheKey.js.html","title":"Source: ReactCacheKey.js","body":" moize Modules moize Source: ReactCacheKey.js // @flow // utils import {getKeyCount} from './utils'; /** * @private * * @class ReactCacheKey * * @classdesc * cache key used specifically for react components */ class ReactCacheKey { constructor(key: Array&lt;Object&gt;) { this.key = { context: this._getKeyPart(key[1]), props: this._getKeyPart(key[0]) }; return this; } key: any; /** * @function _getKeyPart * @memberof ReactCacheKey * @instance * * @description * get the object of metadata for the key part * * @param {Object} keyPart the key part to get the metadata of * @returns {Object} the metadata for the key part */ _getKeyPart(keyPart: ?Object): Object { const keys = keyPart ? Object.keys(keyPart) : []; return { keys, size: keys.length, value: keyPart }; } /** * @function _isPropShallowEqual * @memberof ReactCacheKey * @instance * * @description * check if the prop value passed is equal to the key's value * * @param {Object} object the new key to test against the instance * @param {Object} existing the key object stored in the instance * @param {Array&lt;string&gt;} existing.keys the keys of the existing object * @param {number} existing.size the length of the keys array * @param {Object} value the value of the key part * @returns {boolean} is the prop value shallow equal to the object */ _isPropShallowEqual(object: Object, existing: Object): boolean { if (getKeyCount(object) !== existing.size) { return false; } let index: number = 0, key: string; while (index &lt; existing.size) { key = existing.keys[index]; if (object[key] !== existing.value[key]) { return false; } index++; } return true; } /** * @function _isPropCustomEqual * @memberof ReactCacheKey * @instance * * @description * check if the prop value passed is equal to the key's value * * @param {Object} object the new key to test against the instance * @param {Object} existingObject the key stored in the instance * @param {function} isEqual custom equality comparator * @returns {boolean} are the objects equal based on the isEqual method passed */ _isPropCustomEqual(object: Object, existingObject: Object, isEqual: Function): boolean { return isEqual(object, existingObject); } /** * @function matches * @memberof ReactCacheKey * @instance * * @description * does the passed key match the key in the instance * * @param {Array&lt;*&gt;} key the key to test * @returns {boolean} does the key passed match that in the instance */ matches(key: Array&lt;Object&gt;): boolean { return this._isPropShallowEqual(key[0], this.key.props) &amp;&amp; this._isPropShallowEqual(key[1], this.key.context); } /** * @function matchesCustom * @memberof ReactCacheKey * @instance * * @description * does the passed key match the key in the instance * * @param {Array&lt;*&gt;} key the key to test * @param {function} isEqual method to check equality of keys * @returns {boolean} does the key passed match that in the instance */ matchesCustom(key: Array&lt;Object&gt;, isEqual: Function): boolean { return ( this._isPropCustomEqual(key[0], this.key.props.value, isEqual) &amp;&amp; this._isPropCustomEqual(key[1], this.key.context.value, isEqual) ); } } export default ReactCacheKey; × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"SerializedCacheKey.js.html":{"id":"SerializedCacheKey.js.html","title":"Source: SerializedCacheKey.js","body":" moize Modules moize Source: SerializedCacheKey.js // @flow /** * @private * * @class SerializedCacheKey * * @classdesc * cache key used when the parameters should be serialized */ class SerializedCacheKey { constructor(key: Array&lt;any&gt;) { this.key = key; return this; } key: any; /** * @function matches * @memberof SerializedCacheKey * @instance * * @description * does the passed key match the key in the instance *W * @param {Array&lt;*&gt;} key the key to test * @returns {boolean} does the key passed match that in the instance */ matches(key: Array&lt;any&gt;): boolean { return key === this.key; } /** * @function matchesCustom * @memberof SerializedCacheKey * @instance * * @description * does the passed key match the key in the instance based on the custom equality function passed * * @param {Array&lt;*&gt;} key the key to test * @param {function} isEqual method to compare equality of the keys * @returns {boolean} does the key passed match that in the instance */ matchesCustom(key: Array&lt;any&gt;, isEqual: Function): boolean { return isEqual(key, this.key); } } export default SerializedCacheKey; × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"StandardCacheKey.js.html":{"id":"StandardCacheKey.js.html","title":"Source: StandardCacheKey.js","body":" moize Modules moize Source: StandardCacheKey.js // @flow /** * @private * * @class StandardCacheKey * * @classdesc * cache key used when there is a single standard parameter */ class StandardCacheKey { constructor(key: Array&lt;any&gt;) { this.key = this._isMultiParamKey(key) ? key : key[0]; this.size = key.length; return this; } key: any; size: number; /** * @function _isMultiParamKey * @memberof StandardCacheKey * @instance * * @description * is the key passed a multiple-parameter key * * @param {Array&lt;*&gt;} key the key to test * @returns {boolean} is the key a multiple-parameter key */ _isMultiParamKey(key: Array&lt;any&gt;): boolean { return key.length &gt; 1; } /** * @function _matchesMultiple * @memberof StandardCacheKey * @instance * * @description * does the passed key match the key in the instance * * @param {Array&lt;*&gt;} key the key to test * @returns {boolean} does the key passed match that in the instance */ _matchesMultiple(key: Array&lt;any&gt;): boolean { if (key.length !== this.size) { return false; } let index: number = 0; while (index &lt; this.size) { if (key[index] !== this.key[index]) { return false; } index++; } return true; } /** * @function _matchesSingle * @memberof StandardCacheKey * @instance * * @description * does the passed key match the key in the instance * * @param {Array&lt;*&gt;} key the key to test * @returns {boolean} does the key passed match that in the instance */ _matchesSingle(key: Array&lt;any&gt;): boolean { return key[0] === this.key; } /** * @function matches * @memberof StandardCacheKey * @instance * * @description * does the passed key match the key in the instance * * @param {Array&lt;*&gt;} key the key to test * @returns {boolean} does the key passed match that in the instance */ matches(key: Array&lt;any&gt;): boolean { return this._isMultiParamKey(key) ? this._matchesMultiple(key) : this._matchesSingle(key); } /** * @function matchesCustom * @memberof StandardCacheKey * @instance * * @description * does the passed key match the key in the instance based on the custom equality function passed * * @param {Array&lt;*&gt;} key the key to test * @param {function} isEqual method to compare equality of the keys * @returns {boolean} does the key passed match that in the instance */ matchesCustom(key: Array&lt;any&gt;, isEqual: Function): boolean { return isEqual(this._isMultiParamKey(key) ? key : key[0], this.key); } } export default StandardCacheKey; × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" moize Modules moize Modules × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" moize Modules moize moize 4.0.3 moize moize is a blazing fast memoization library for JavaScript. It handles multiple parameters (including default values) without any additional configuration, and offers options to help satisfy a number of implementation-specific needs. It has no dependencies, and is ~3.2kb when minified and gzipped. Table of contents Upgrade notification Installation Usage Advanced usage equals isPromise isReact maxAge maxArgs maxSize onExpire promiseLibrary serialize serializeFunctions serializer transformArgs updateExpire Usage with shortcut methods moize.maxAge moize.maxArgs moize.maxSize moize.promise moize.react moize.reactSimple moize.serialize moize.simple Composition Introspection isMoized Benchmarks Single parameter Multiple parameters (primitives only) Multiple parameters (complex objects) Direct cache manipulation add clear has keys remove values Browser support Development Upgrade notification Users of moize 2.x.x may experience breaking changes, especially if using a custom cache or using moize.react in a mutative way. Please see the changelog for more details about how to manage the upgrade. Installation $ npm i moize --saveUsage import moize from 'moize'; const method = (a, b) =&gt; { return a + b; }; const memoized = moize(method); memoized(2, 4); // 6 memoized(2, 4); // 6, pulled from cacheAll parameter types are supported, including circular objects, functions, etc. There are also a number of shortcut methods to easily create memoization for targeted use-cases. You can even memoize functional React components based on their props + context combination (see the isReact option, or the moize.react shortcut method)! Advanced usage moize optionally accepts an object of options as either the second parameter or as the first step in a curried function: // inline moize(fn, options); // curried moize(options)(fn);The full shape of these options: { equals: Function, // custom method to compare equality between two objects isPromise: boolean, // is the result a promise isReact: boolean, // is the result a React component maxAge: number, // amount of time in milliseconds before the cache will expire maxArgs: number, // maximum number of arguments to use as key for caching maxSize: number, // maximum size of cache for this method promiseLibrary: Function|Object, // promise library to use when isPromise is true, if not using native promises serialize: boolean, // should the parameters be serialized instead of directly referenced serializeFunctions: boolean, // should functions be included in the serialization of multiple parameters serializer: Function // method to serialize the arguments to build a unique cache key }equals defaults to strict equality Custom method used to compare equality of keys for cache purposes. // using fast-equals's deep equal comparison method import {deepEqual} from 'fast-equals'; const fn = ({foo, bar}) =&gt; { return [foo, bar]; }; const memoized = moize(fn, { equals: deepEqual }); memoized({foo: 'foo', bar: 'bar'}); memoized({foo: 'foo', bar: 'bar'}); // pulls from cacheThe equals method receives two parameters (cache key values) and should return a boolean. Please note that this will be slower than the default strict equality comparison, however how much slower is based on the efficiency of the method passed. isPromise defaults to false Is the computed value in the function a Promise, and should we cache the resolved value from that Promise. This is also available via the shortcut method of moize.promise. const fn = async (item) =&gt; { return await item; }; const memoized = moize(fn, { isPromise: true });The resolved value of the Promise will be stored in cache as a Promise itself, so that cached returns will always be in the form of a Promise. For common usage reasons, if the Promise is rejected, the cache entry will be deleted. Also, if a maxAge is provided, the countdown of that TTL will begin upon the resolution of the promise rather than at the instantiation of it. isReact defaults to false Is the function passed a stateless functional React component. This is also available via the shortcut method of moize.react. const Foo = ({bar, baz}) =&gt; { return ( &lt;div&gt; {bar}: {baz} &lt;/div&gt; ); }; export default moize(Foo, { isReact: true });The method will do a shallow comparison of both props and context of the component based on strict equality. If you have mutative props and instead want to do a deep equals comparison, provide a custom equals option. maxAge defaults to Infinity The maximum amount of time in milliseconds that you want a computed value to be stored in cache for this method. This is also available via the shortcut method of moize.maxAge. const fn = (item) =&gt; { return item; }; const memoized = moize(fn, { maxAge: 1000 * 60 * 5 // five minutes });maxArgs defaults to the length of arguments passed to the method The maximum number of arguments used in creating the key for the cache. This is also available via the shortcut method of moize.maxArgs. const fn = (item1, item2, item3) =&gt; { return item1 + item2 + item3; }; const memoized = moize(fn, { maxArgs: 2 }); memoize('foo', 'bar', 'baz'); memoize('foo', 'bar', 'quz'); // pulls from cache, as the first two args are the samePlease note that if maxArgs is combined with either serialize or transformArgs, the following order is used: limit by maxArgs transform by transformArgs (if applicable) serialize by serializer (if applicable) maxSize defaults to Infinity The maximum number of values you want stored in cache for this method. Clearance of the cache once the maxSize is reached is on a Least Recently Used basis. This is also available via the shortcut method of moize.maxSize. const fn = (item) =&gt; { return item; }; const memoized = moize(fn, { maxSize: 5 });onExpire A callback that is called when one of cache item expires. Note that maxAge must also be set because by default keys never expire. const fn = (item) =&gt; { return item; }; const memoized = moize(fn, { maxAge: 10000, onExpire(key) { console.log(key); }, });If you return false from this method, it will prevent the key's removal, instead refreshing the expiration in the same vein as updateExpire based on maxAge: const fn = (item) =&gt; { return item; }; let expirationAttempts = 0; const memoized = moize(fn, { maxAge: 1000 * 10, // 10 seconds onExpire(key) { expirationAttempts++; return expirationAttempts &lt; 2; }, }); memoized('foo'); // will expire key after 30 seconds, or 3 expiration attemptspromiseLibrary defaults to native Promise The promise library to use for resolution / rejection of promises. const fn = (foo) =&gt; { return new Bluebird((resolve) =&gt; { resolve(foo); }); }; const memoized = moize(fn, { isPromise: true, promiseLibrary: Bluebird });Please note that for this option to work isPromise must be set to true. You can use any library where the following aspects of the specification are included: It is thenable (the generated promise has a .then() function) The Promise object itself has .resolve() and .reject() functions on it Most modern libraries (bluebird, q, etc.) include these by default, however if you are using a custom library that does not meet these requirements then you will need to implement them yourself. An example of a wrapper that creates the .resolve() and .reject() methods: import foo from 'my-promise-library'; // create a wrapper so as not to touch the library itself const customPromise = (fn) =&gt; { return foo(fn); }; // lets pretend foo has a .result() method that has the first // parameter as successful, second as failure customPromise.resolve = function(value) { return foo.result(value); }; customPromise.reject = function(error) { return foo.result(undefined, error); }; const fn = (foo) =&gt; { return customPromise((resolve) =&gt; { resolve(foo); }); }; const memoized = moize(fn, { isPromise: true, promiseLibrary: customPromise });serialize defaults to false Serializes the parameters passed into a string and uses this as the key for cache comparison. This is also available via the shortcut method of moize.serialize. const fn = (mutableObject) =&gt; { return mutableObject.foo; }; const memoized = moize(fn, { serialize: true }); const object = { foo: 'foo' }; memoized(object); // 'foo' object.foo = 'bar'; memoized(object); // 'bar'Please note that this is slower than the default key storage (see benchmarks). Also note that if serialize is combined with either maxArgs or transformArgs, the following order is used: limit by maxArgs (if applicable) transform by transformArgs (if applicable) serialize by serializer serializeFunctions defaults to false A custom replacer is used when serializing to ensure functions are included in the key serialization. const FunctionalComponent = ({onClickFoo}) =&gt; { return ( &lt;button onClick={onClickFoo} type=&quot;button&quot; &gt; Click me! &lt;/button&gt; ) }; const MemoizedFunctionalComponent = moize(FunctionalComponent, { serialize: true, serializeFunctions: true });Please note that you must also set serialize to true for this setting to take effect. serializer defaults to serializeArguments in utils.js Overrides the internal serializer when serializing the parameters for cache key comparison. The value returned from the function must be a valid value of keys for a Map; it does not need to a string, but should be unique from a strict equality perspective. const serializer = (args) =&gt; { return JSON.stringify(args[0]); }; const memoized = moize(fn, { serialize: true, serializer });Please note that you must also set serialize to true for this setting to take effect. transformArgs Transform the arguments passed before it is used as a key. The function accepts a single argument, the Array of args, and must also return an Array. const fn = (one, two, three) =&gt; { return [two, three]; }; const ignoreFirstArg = (args) =&gt; { return args.slice(1); }; const moized = moize(fn, { transformArgs: ignoreFirstArg }); moize('foo', 'bar', 'baz'); moize(null, 'bar', 'baz'); // pulled from cachePlease note that if transformArgs is combined with either maxArgs or serialize, the following order is used: limit by maxArgs (if applicable) transform by transformArgs serialize by serializer (if applicable) updateExpire When a maxAge is set, clear out the scheduled expiration of the key whenever that key is retrieved, updating the new expiration to be based on the last retrieval from cache. const fn = (item) =&gt; { return item; }; const memoized = moize(fn, { maxAge: 1000 * 60 * 5, // five minutes updateExpire: true }); memoized('foo'); setTimeout(() =&gt; { memoized('foo'); // hits cache, which updates the expire to be 5 minutes from this run instead of the first }, 1000 * 60);Usage with shortcut methods moize.maxAge Pre-applies the maxAge option as a curriable method. import moize from 'moize'; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.maxAge(5000)(foo);moize.maxArgs Pre-applies the maxArgs option as a curriable method. import moize from 'moize'; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.maxArgs(1)(foo);moize.maxSize Pre-applies the maxSize option as a curriable method. import moize from 'moize'; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.maxSize(5)(foo);moize.promise Pre-applies the isPromise option. import moize from 'moize'; const foo = async (bar, baz) =&gt; { return await someApiCall(bar, baz); }; export default moize.promise(foo);Please note that if you want to provide a custom promiseLibrary, you must do so with additional options: const additionalOptions = { promiseLibrary: Bluebird }; moize.promise(fn, additionalOptions); // or moize.promise(additionalOptions)(fn);moize.react Shortcut for memoizing functional components in React. This uses a special cache key that will do a shallow equal comparison of changes to both props and context. import moize from 'moize'; const Foo = ({bar, baz}) =&gt; { return ( &lt;div&gt; {bar} {baz} &lt;/div&gt; ); }; export default moize.react(Foo);Also, it should be noted that in usages that involve a lot of variety in the parameter changes, this has the potential for excessive memory consumption, as the cache will retain the history of all elements. It is therefore recommended to apply a maxSize, or to use the shortcut method moize.reactSimple, which automatically sets the maxSize to 1. Please note moize.react will not operate with components made via the class instantiation, as they do not offer the same referential transparency. moize.reactSimple Shortcut for memoizing functional components in React, with the cache size limited to a single entry. This mimics the PureComponent optimization, where the cache will only contain the component with the most recent props and context combination. import moize from 'moize'; const Foo = ({bar, baz}) =&gt; { return ( &lt;div&gt; {bar} {baz} &lt;/div&gt; ); }; export default moize.reactSimple(Foo);Please note moize.reactSimple will not operate with components made via the class instantiation, as they do not offer the same referential transparency. moize.serialize Pre-applies the serialize option. import moize from 'moize'; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.serialize(foo);Please note that if you want to serializeFunctions or provide a custom serializer, you must do so with additional options: const additionalOptions = { serializeFunctions: true }; moize.serialize(fn, additionalOptions); // or moize.serialize(additionalOptions)(fn);moize.simple Pre-applies the maxSize option with 1. import moize from 'moize'; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.simple(foo);Composition Starting with version 2.3.0, you can compose moize methods. This will create a new memoized method with the original function that shallowly merges the options of the two setups. Example: import moize from 'moize'; const Foo = (props) =&gt; { return ( &lt;div {...props}/&gt; ); }; // memoizing with react, as since 2.0.0 const MemoizedFoo = moize.react(Foo); // creating a separately-memoized method that has maxSize of 5 const LastFiveFoo = moize.maxSize(5)(MemoizedFoo);You can also create an options-first curriable version of moize if you only pass the options: import moize from 'moize'; // creates a function that will memoize what is passed const limitedSerializedMoize = moize({ maxSize: 5, serialize: true }); const foo = (bird) =&gt; { return `${bird} is the word`; }; const moizedFoo = limitedSerializedMoize(foo);You can also combine all of these options with moize.compose to create moize wrappers with pre-defined options. import moize from 'moize'; // creates a moizer that will have the options of // {isReact: true, maxAge: 5000, maxSize: 5} const superLimitedReactMoize = moize.compose(moize.react, moize.maxSize(5), moize.maxAge(5000));Introspection There currently is only one method to introspect objects specific to moize, but if you want more just ask! isMoized Is the function passed a moized function. const fn = () =&gt; {}; const moizedFn = moize(fn); moize.isMoized(fn); // false moize.isMoized(moizedFn); // trueBenchmarks All values provided are the number of operations per second (ops/sec) calculated by the Benchmark suite. Note that underscore, lodash, and ramda do not support mulitple-parameter memoization, so they are not included in those benchmarks. Each benchmark was performed using the default configuration of the library, with a fibonacci calculation based on a starting parameter of 35, and in the case of multiple parameters a second parameter (boolean for primitives, object for complex objects) was used. Single parameter Operations / second Relative margin of error moize 44,547,124 0.64% fast-memoize 30,048,291 0.97% moize (serialized) 14,877,726 0.63% underscore 13,821,853 0.61% memoizee 11,494,292 0.90% lodash 10,020,324 0.52% lru-memoize 10,017,832 1.30% Addy Osmani 4,423,578 0.76% memoizerific 2,174,503 1.31% ramda 1,171,053 0.71% Multiple parameters (primitives only) Operations / second Relative margin of error moize 24,947,214 0.77% moize (serialized) 10,982,454 0.84% memoizee 8,602,634 0.59% lru-memoize 7,667,460 1.58% Addy Osmani 2,039,761 0.86% memoizerific 1,336,321 0.81% fast-memoize 844,633 0.76% Multiple parameters (complex objects) Operations / second Relative margin of error moize 24,146,198 1.16% memoizee 8,324,025 0.86% lru-memoize 7,986,555 1.15% moize (serialized) 1,798,895 0.95% memoizerific 1,416,617 1.15% Addy Osmani 1,097,775 0.78% fast-memoize 746,371 1.03% Direct cache manipulation There are a few methods provided on the moized function which allow for programmatic manipulation of the cache: add(key, value) This will manually add the value at key in cache if key does not already exist. key is an Array of values, meant to reflect the arguments passed to the method. // single parameter is straightforward const memoized = moize((item) =&gt; { return item; }); memoized.add(['foo'], 'bar'); // pulls from cache memoized('foo');clear() This will clear all values in the cache, resetting it to an empty state. const memoized = moize((item) =&gt; { return item; }); memoized.clear();has(key) This will return true if a cache entry exists for the key passed, else will return false. key is an Array of values, meant to reflect the arguments passed to the method. const memoized = moize((first, second) =&gt; { return [first, second]; }); memoized('foo', 'bar'); console.log(memoized.has(['foo', 'bar'])); // true console.log(memoized.has(['bar', 'baz'])); // falsekeys() This will return a list of the current keys in cache. const memoized = moize((item) =&gt; { return item; }); const foo = 'foo'; memoized(foo); const bar = { baz: 'baz' }; memoized(bar); const keys = memoized.keys(); // ['foo', {baz: 'baz'}]remove(key) This will remove the provided key from cache. key is an Array of values, meant to reflect the arguments passed to the method. const memoized = moize((item) =&gt; { return item; }); const foo = { bar: 'baz' }; memoized(foo); memoized.remove([foo]); // will re-execute, as it is no longer in cache memoized(foo);values() This will return a list of the current values in cache when the native Cache. const memoized = moize((item) =&gt; { return { item }; }); const foo = 'foo'; memoized(foo); const bar = { baz: 'baz' }; memoized(bar); const values = memoized.values(); // [{item: 'foo'}, {item: {baz: 'baz'}}]Browser support Chrome (all versions) Firefox (all versions) Edge (all versions) Opera 15+ IE 9+ Safari 6+ iOS 8+ Android 4+ Development Standard stuff, clone the repo and npm install dependencies. The npm scripts available: build =&gt; run webpack to build development dist file with NODE_ENV=development build:minifed =&gt; run webpack to build production dist file with NODE_ENV=production dev =&gt; run webpack dev server to run example app (playground!) dist =&gt; runs build and build-minified docs =&gt; builds the docs via jsdoc lint =&gt; run ESLint against all files in the src folder prepublish =&gt; runs compile-for-publish prepublish:compile =&gt; run lint, test, transpile:es, transpile:lib, dist test =&gt; run AVA test functions with NODE_ENV=test test:coverage =&gt; run test but with nyc for coverage checker test:watch =&gt; run test, but with persistent watcher transpile:lib =&gt; run babel against all files in src to create files in lib transpile:es =&gt; run babel against all files in src to create files in es, preserving ES2015 modules (for pkg.module) × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "},"module-moize.html":{"id":"module-moize.html","title":"Module: moize","body":" moize Modules moize Module: moize Source: index.js, line 29 Methods &lt;inner&gt; compose(functions) method to compose moized methods and return a single moized function Parameters: Name Type Argument Description functions Array.&lt;(function())&gt; &lt;repeatable&gt; the functions to compose Source: index.js, line 123 Returns: the composed function Type function &lt;inner&gt; isMoized(fn) is the fn passed a moized function Parameters: Name Type Description fn * the object to test Source: index.js, line 110 Returns: is fn a moized function Type boolean &lt;inner&gt; maxAge(functions) a moized method where the age of the cache is limited to the number of milliseconds passed Parameters: Name Type Argument Description functions Array.&lt;*&gt; &lt;repeatable&gt; the functions to compose Source: index.js, line 134 Returns: the moized function Type * &lt;inner&gt; maxArgs(functions) a moized method where the number of arguments used for determining cache is limited to the value passed Parameters: Name Type Argument Description functions Array.&lt;*&gt; &lt;repeatable&gt; the functions to compose Source: index.js, line 145 Returns: the moized function Type * &lt;inner&gt; maxSize(functions) a moized method where the total size of the cache is limited to the value passed Parameters: Name Type Argument Description functions Array.&lt;*&gt; &lt;repeatable&gt; the functions to compose Source: index.js, line 156 Returns: the moized function Type * &lt;inner&gt; moize(functionOrComposableOptions [, passedOptions]) store cached values returned from calling method with arguments to avoid reprocessing data from same arguments Parameters: Name Type Argument Default Description functionOrComposableOptions function method to memoize passedOptions Options &lt;optional&gt; {} options to customize how the caching is handled Properties Name Type Argument Default Description isPromise boolean &lt;optional&gt; false is the function return expected to be a promise to resolve maxAge number &lt;optional&gt; Infinity the maximum age the value should persist in cache maxArgs number &lt;optional&gt; Infinity the maximum number of arguments to be used in serializing the keys maxSize number &lt;optional&gt; Infinity the maximum size of the cache to retain promiseLibrary function &lt;optional&gt; Promise promise library to use for resolution / rejection serializeFunctions function &lt;optional&gt; false should function parameters be serialized as well serializer function &lt;optional&gt; method to serialize arguments with for cache storage Source: index.js, line 33 Returns: higher-order function which either returns from cache or newly-computed value Type function Example import moize from 'moize'; // standard implementation const fn = (foo, bar) =&gt; { return `${foo} ${bar}`; }; const memoizedFn = moize(fn); // implementation with options const fn = async (id) =&gt; { return get(`http://foo.com/${id}`); }; const memoizedFn = moize(fn, { isPromise: true, maxSize: 5 }); &lt;inner&gt; promise(functions) a moized method specific to caching resolved promise / async values Parameters: Name Type Argument Description functions Array.&lt;*&gt; &lt;repeatable&gt; the functions to compose Source: index.js, line 167 Returns: the moized function Type * &lt;inner&gt; react(functions) a moized method specific to caching React components Parameters: Name Type Argument Description functions Array.&lt;*&gt; &lt;repeatable&gt; the functions to compose Source: index.js, line 180 Returns: the moized function Type * &lt;inner&gt; reactSimple(functions) a moized method specific to caching React components, only keeping the most recently-cached version Parameters: Name Type Argument Description functions Array.&lt;*&gt; &lt;repeatable&gt; the functions to compose Source: index.js, line 193 Returns: the moized function Type * &lt;inner&gt; serialize(functions) a moized method where the arguments passed are cached based on their serialized values Parameters: Name Type Argument Description functions Array.&lt;*&gt; &lt;repeatable&gt; the functions to compose Source: index.js, line 204 Returns: the moized function Type * &lt;inner&gt; simple(functions) a moized method where only the most recent key =&gt; value combination is cached Parameters: Name Type Argument Description functions Array.&lt;*&gt; &lt;repeatable&gt; the functions to compose Source: index.js, line 217 Returns: the moized function Type * × Search results Close Documentation generated by JSDoc 3.5.5 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
