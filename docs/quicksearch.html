<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"Cache.js.html":{"id":"Cache.js.html","title":"Source: Cache.js","body":" moize Modules moize Global isMoized Source: Cache.js // @flow // types import type {ListItem} from './types'; // utils import {findIndex, findIndexAfterFirst, splice, unshift} from './utils'; /** * @private * * @class Cache * * @classdesc * class that is similar to the Map infrastructure, but faster and * more targeted to moize use cases */ class Cache { lastItem: ListItem = {}; list: Array&lt;ListItem&gt; = []; size: number = 0; /** * @function add * @memberof Cache * @instance * * @description * add a new item to cache * * @param {*} key the key to assign * @param {*} value the value to assign at key */ add(key: any, value: any): any { this.lastItem = unshift(this.list, { key, value }); this.size++; } /** * @function clear * @memberof Cache * @instance * * @description * clear the cache of all items */ clear() { this.lastItem = {}; this.list.length = this.size = 0; } /** * @function expireAfter * @memberof Cache * @instance * * @description * remove from cache after maxAge time has passed * * @param {*} key the key to remove * @param {number} maxAge the time in milliseconds to wait before removing key */ expireAfter(key: any, maxAge: number) { setTimeout(() =&gt; { this.remove(key); }, maxAge); } /** * @function get * @memberof Cache * @instance * * @description * get the value of an item from cache if it exists * * @param {*} key the key to get the value of * @returns {*} the value at key */ get(key: any): any { if (!this.size) { return; } if (key === this.lastItem.key) { return this.lastItem.value; } const index: number = findIndexAfterFirst(this.list, key); if (~index) { this.lastItem = this.list[index]; return unshift(splice(this.list, index), this.lastItem).value; } } /** * @private * * @function has * * @description * does the key exist in the cache * * @param {*} key the key to find in cache * @returns {boolean} does the key exist in cache */ has(key: any): boolean { return ( this.size !== 0 &amp;&amp; (key === this.lastItem.key || !!~findIndexAfterFirst(this.list, key)) ); } /**= * @function remove * @memberof Cache * @instance * * @description * remove the item at key from cach * * @param {*} key the key to remove from cache * @returns {void} */ remove(key: any) { const index: number = findIndex(this.list, key); if (~index) { splice(this.list, index); if (this.size === 1) { return this.clear(); } this.size--; if (!index) { this.lastItem = this.list[0]; } } } /** * @function update * @memberof Cache * @instance * * @description * update an item in-place with a new value * * @param {*} key key to update value of * @param {*} value value to store in the map at key */ update(key: any, value: any) { const index: number = findIndex(this.list, key); if (~index) { this.list[index].value = value; if (this.lastItem &amp;&amp; key === this.lastItem.key) { this.lastItem.value = value; } } } } export default Cache; × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"utils.js.html":{"id":"utils.js.html","title":"Source: utils.js","body":" moize Modules moize Global isMoized Source: utils.js // @flow // cache import Cache from './Cache'; // cache key import ReactCacheKey from './ReactCacheKey'; import SerializedCacheKey from './SerializedCacheKey'; import SingleParameterCacheKey from './SingleParameterCacheKey'; import MultipleParameterCacheKey from './MultipleParameterCacheKey'; // constants import { DEFAULT_OPTIONS, FINITE_POSITIVE_INTEGER, FUNCTION_NAME_REGEXP, FUNCTION_TYPEOF, GOTCHA_OBJECT_CLASSES, INVALID_PROMISE_LIBRARY_ERROR, OBJECT_TYPEOF, STATIC_PROPERTIES_TO_PASS } from './constants'; // serialize import {getSerializerFunction} from './serialize'; // types import type {ListItem, Options} from './types'; type StandardCacheKey = MultipleParameterCacheKey | SingleParameterCacheKey; type CacheKey = ReactCacheKey | SerializedCacheKey | StandardCacheKey; /** * @private * * @function isComplexObject * * @description * is the object passed a complex object * * @param {*} object object to test if it is complex * @returns {boolean} is it a complex object */ export const isComplexObject = (object: any): boolean =&gt; { return !!object &amp;&amp; typeof object === OBJECT_TYPEOF; }; /** * @private * * @function isFiniteAndPositiveInteger * * @description * is the number passed an integer that is finite and positive * * @param {number} number number to test for finiteness and positivity * @returns {boolean} is the number finite and positive */ export const isFiniteAndPositiveInteger = (number: number): boolean =&gt; { return FINITE_POSITIVE_INTEGER.test(`${number}`); }; /** * @private * * @function isFunction * * @description * is the object passed a function or not * * @param {*} object object to test * @returns {boolean} is it a function */ export const isFunction = (object: any): boolean =&gt; { return typeof object === FUNCTION_TYPEOF; }; /** * @function isMoized * * @description * is the function passed a moized function or not * * @param {*} fn the function to get if moize * @returns {boolean} is the function moized or not */ export const isMoized = (fn: any): boolean =&gt; { return isFunction(fn) &amp;&amp; !!fn.isMoized; }; /** * @private * * @function isPlainObject * * @description * is the object passed a plain object or not * * @param {*} object object to test * @returns {boolean} is it a plain object */ export const isPlainObject = (object: any): boolean =&gt; { return isComplexObject(object) &amp;&amp; object.constructor === Object; }; /** * @private * * @function isValueObjectOrArray * * @description * check if the object is actually an object or array * * @param {*} object object to test * @returns {boolean} is the object an object or array */ export const isValueObjectOrArray = (object: any): boolean =&gt; { if (!isComplexObject(object)) { return false; } let index = 0; while (index &lt; GOTCHA_OBJECT_CLASSES.length) { if (object instanceof GOTCHA_OBJECT_CLASSES[index]) { return false; } index++; } return true; }; /** * @private * * @function take * * @description * take the first N number of items from the array (faster than slice) * * @param {number} size the number of items to take * @returns {function(Array&lt;*&gt;): Array&lt;*&gt;} the shortened array */ export const take = (size: number) =&gt; { return (array: Array&lt;any&gt;): Array&lt;any&gt; =&gt; { if (size &gt;= array.length) { return array; } switch (size) { case 1: return [array[0]]; case 2: return [array[0], array[1]]; case 3: return [array[0], array[1], array[2]]; case 4: return [array[0], array[1], array[2], array[3]]; case 5: return [array[0], array[1], array[2], array[3], array[4]]; } return array.slice(0, size); }; }; /** * @private * * @function addStaticPropertiesToFunction * * @description * add static properties to the memoized function if they exist on the original * * @param {function} originalFunction the function to be memoized * @param {function} memoizedFn the higher-order memoized function * @returns {function} memoizedFn with static properties added */ export const addStaticPropertiesToFunction = ( originalFunction: Function, memoizedFn: Function ): Function =&gt; { let index: number = STATIC_PROPERTIES_TO_PASS.length, property: string; while (index--) { property = STATIC_PROPERTIES_TO_PASS[index]; if (originalFunction[property]) { memoizedFn[property] = originalFunction[property]; } } return memoizedFn; }; /** * @private * * @function compose * * @description * method to compose functions and return a single function * * @param {...Array&lt;function&gt;} functions the functions to compose * @returns {function(...Array&lt;*&gt;): *} the composed function */ export const compose = (...functions: Array&lt;Function&gt;): Function =&gt; { return functions.reduce((f: Function, g: Function): Function =&gt; { return (...args: Array&lt;any&gt;): any =&gt; { return f(g(...args)); }; }); }; /** * @private * * @function createCurriableOptionMethod * * @description * create a method that will curry moize with the option + value passed * * @param {function} fn the method to call * @param {string} option the name of the option to apply * @param {*} value the value to assign to option * @returns {function} the moizer with the option pre-applied */ export const createCurriableOptionMethod = ( fn: Function, option: string ): Function =&gt; { return function(value: any): Function { return fn({ [option]: value }); }; }; /** * @private * * @function createFindIndex * * @description * create a findIndex method based on the startingIndex passed * * @param {number} startingIndex the index to start in the find method returned * @returns {function(Array&lt;ListItem&gt;, *): number} the findIndex method */ export const createFindIndex = (startingIndex: number): Function =&gt; { // eslint-disable-line no-use-before-define return (list: Array&lt;ListItem&gt;, key: any): number =&gt; { let index: number = startingIndex; while (index &lt; list.length) { if (key === list[index].key) { return index; } index++; } return -1; }; }; /** * @private * * @function createPluckFromInstanceList * * @description * get a property from the list on the cache * * @param {{list: Array&lt;Object&gt;}} cache cache whose list to map over * @param {string} key key to pluck from list * @returns {Array&lt;*&gt;} array of values plucked at key */ export const createPluckFromInstanceList = ( cache: Cache, key: string ): Function =&gt; { return (): Array&lt;any&gt; =&gt; { return cache.list.map((item: ListItem) =&gt; { return item[key]; }); }; }; /** * @private * * @function createPromiseRejecter * * @description * create method that will reject the promise and delete the key from cache * * @param {Cache} cache cache to update * @param {*} key key to delete from cache * @param {function} promiseLibrary the promise library used * @returns {function} the rejecter function for the promise */ export const createPromiseRejecter = ( cache: Cache, key: any, {promiseLibrary}: Options ): Function =&gt; { return (exception: Error): Promise&lt;any&gt; =&gt; { cache.remove(key); return promiseLibrary.reject(exception); }; }; /** * @private * * @function createPromiseResolver * * @description * create method that will resolve the promise and update the key in cache * * @param {Cache} cache cache to update * @param {*} key key to update in cache * @param {boolean} hasMaxAge should the cache expire after some time * @param {number} maxAge the age after which the cache will be expired * @param {function} promiseLibrary the promise library used * @returns {function} the resolver function for the promise */ export const createPromiseResolver = ( cache: Cache, key: any, hasMaxAge: boolean, {maxAge, promiseLibrary}: Options ) =&gt; { return (resolvedValue: any): Promise&lt;any&gt; =&gt; { cache.update(key, promiseLibrary.resolve(resolvedValue)); if (hasMaxAge) { cache.expireAfter(key, maxAge); } return resolvedValue; }; }; /** * @private * * @function findIndex * * @description * find the index of the key starting at the first index * * @param {Array&lt;ListItem&gt;} list the list to find the key in * @param {*} key the key to test against * @returns {number} the index of the matching key, or -1 */ export const findIndex: Function = createFindIndex(0); /** * @private * * @function findIndexAfterFirst * * @description * find the index of the key starting at the second index * * @param {Array&lt;ListItem&gt;} list the list to find the key in * @param {*} key the key to test against * @returns {number} the index of the matching key, or -1 */ export const findIndexAfterFirst: Function = createFindIndex(1); /** * @private * * @function getDefaultedOptions * * @description * get the options coalesced to their defaults * * @param {Object} options the options passed to the moize method * @returns {Options} the coalesced options object */ export const getDefaultedOptions = (options: Object): Options =&gt; { let coalescedOptions: Object = { ...DEFAULT_OPTIONS, ...options }; if (coalescedOptions.serialize) { coalescedOptions.serializer = getSerializerFunction(coalescedOptions); } return coalescedOptions; }; /** * @private * * @function getFunctionNameViaRegexp * * @description * use regexp match on stringified function to get the function name * * @param {function} fn function to get the name of * @returns {string} function name */ export const getFunctionNameViaRegexp = (fn: Function): string =&gt; { const match: ?Array&lt;string&gt; = fn.toString().match(FUNCTION_NAME_REGEXP); return match ? match[1] : ''; }; /** * @private * * @function getFunctionName * * @description * get the function name, either from modern property or regexp match, * falling back to generic string * * @param {function} fn function to get the name of * @returns {string} function name */ export const getFunctionName = (fn: Function): string =&gt; { return ( fn.displayName || fn.name || getFunctionNameViaRegexp(fn) || FUNCTION_TYPEOF ); }; /** * @private * * @function getReactCacheKey * * @description * get the cache key specific to react * * @param {Cache} cache the cache to find a potential matching key in * @param {*} key the key to try to find a match of, or turn into a new ReactCacheKey * @returns {ReactCacheKey} the matching cache key, or a new one */ export const getReactCacheKey = ( cache: Cache, key: Array&lt;any&gt; ): ReactCacheKey =&gt; { // $FlowIgnore if cache has size, the key exists if (cache.size &amp;&amp; cache.lastItem.key.matches(key)) { // $FlowIgnore if the key matches, the key exists return cache.lastItem.key; } let index: number = 1; while (index &lt; cache.size) { // $FlowIgnore if cache has size, the key exists if (cache.list[index].key.matches(key)) { // $FlowIgnore if the key matches, the key exists return cache.list[index].key; } index++; } return new ReactCacheKey(key); }; /** * @private * * @function getReactCacheKey * * @description * get the cache key specific to react * * @param {Cache} cache the cache to find a potential matching key in * @param {*} key the key to try to find a match of, or turn into a new ReactCacheKey * @param {Options} options the options passed to the moized method * @returns {ReactCacheKey} the matching cache key, or a new one */ export const getReactCacheKeyCustomEquals = ( cache: Cache, key: Array&lt;any&gt;, options: Options ): ReactCacheKey =&gt; { // $FlowIgnore if cache has size, the key exists if (cache.size &amp;&amp; cache.lastItem.key.matchesCustom(key, options.equals)) { // $FlowIgnore if the key matches, the key exists return cache.lastItem.key; } let index: number = 1; while (index &lt; cache.size) { // $FlowIgnore if cache has size, the key exists if (cache.list[index].key.matchesCustom(key, options.equals)) { // $FlowIgnore if the key matches, the key exists return cache.list[index].key; } index++; } return new ReactCacheKey(key); }; /** * @private * * @function getSerializedCacheKey * * @description * get the cache key specific to serialized methods * * @param {Cache} cache the cache to find a potential matching key in * @param {*} key the key to try to find a match of, or turn into a new SerializedCacheKey * @param {Options} options the options passed to the moized method * @returns {SerializedCacheKey} the matching cache key, or a new one */ export const getSerializedCacheKey = ( cache: Cache, key: Array&lt;any&gt;, options: Options ): SerializedCacheKey =&gt; { const serializedKey = options.serializer(key); // $FlowIgnore if cache has size, the key exists if (cache.size &amp;&amp; cache.lastItem.key.matches(serializedKey)) { // $FlowIgnore if the key matches, the key exists return cache.lastItem.key; } let index: number = 1; while (index &lt; cache.size) { // $FlowIgnore if cache has size, the key exists if (cache.list[index].key.matches(serializedKey)) { // $FlowIgnore if the key matches, the key exists return cache.list[index].key; } index++; } return new SerializedCacheKey(serializedKey); }; /** * @private * * @function getSerializedCacheKeyCustomEquals * * @description * get the cache key specific to serialized methods * * @param {Cache} cache the cache to find a potential matching key in * @param {*} key the key to try to find a match of, or turn into a new SerializedCacheKey * @param {Options} options the options passed to the moized method * @returns {SerializedCacheKey} the matching cache key, or a new one */ export const getSerializedCacheKeyCustomEquals = ( cache: Cache, key: Array&lt;any&gt;, options: Options ): SerializedCacheKey =&gt; { const serializedKey = options.serializer(key); // $FlowIgnore if cache has size, the key exists if (cache.size &amp;&amp; cache.lastItem.key.matches(serializedKey, options.equals)) { // $FlowIgnore if the key matches, the key exists return cache.lastItem.key; } let index: number = 1; while (index &lt; cache.size) { // $FlowIgnore if cache has size, the key exists if (cache.list[index].key.matches(serializedKey, options.equals)) { // $FlowIgnore if the key matches, the key exists return cache.list[index].key; } index++; } return new SerializedCacheKey(serializedKey); }; /** * @private * * @function getStandardCacheKey * * @description * get the cache key for standard parameters, either single or multiple * * @param {Cache} cache the cache to find a potential matching key in * @param {*} key the key to try to find a match of, or turn into a new Multiple / SingleParameterCacheKey * @returns {StandardCacheKey} the matching cache key, or a new one */ export const getStandardCacheKey = ( cache: Cache, key: Array&lt;any&gt; ): StandardCacheKey =&gt; { const isMultiParamKey: boolean = key.length &gt; 1; // $FlowIgnore if cache has size, the key exists if (cache.size &amp;&amp; cache.lastItem.key.matches(key, isMultiParamKey)) { // $FlowIgnore if the key matches, the key exists return cache.lastItem.key; } let index: number = 1; while (index &lt; cache.size) { // $FlowIgnore if cache has size, the key exists if (cache.list[index].key.matches(key, isMultiParamKey)) { // $FlowIgnore if the key matches, the key exists return cache.list[index].key; } index++; } return isMultiParamKey ? new MultipleParameterCacheKey(key) : new SingleParameterCacheKey(key); }; /** * @private * * @function getStandardCacheKeyCustomEquals * * @description * get the cache key for standard parameters, either single or multiple * * @param {Cache} cache the cache to find a potential matching key in * @param {*} key the key to try to find a match of, or turn into a new Multiple / SingleParameterCacheKey * @param {Options} options the options passed to the moized method * @returns {StandardCacheKey} the matching cache key, or a new one */ export const getStandardCacheKeyCustomEquals = ( cache: Cache, key: Array&lt;any&gt;, options: Options ): StandardCacheKey =&gt; { const isMultiParamKey: boolean = key.length &gt; 1; if ( cache.size &amp;&amp; // $FlowIgnore if cache has size, the key exists cache.lastItem.key.matchesCustom(key, isMultiParamKey, options.equals) ) { // $FlowIgnore if the key matches, the key exists return cache.lastItem.key; } let index: number = 1; while (index &lt; cache.size) { if ( // $FlowIgnore if cache has size, the key exists cache.list[index].key.matchesCustom(key, isMultiParamKey, options.equals) ) { // $FlowIgnore if the key matches, the key exists return cache.list[index].key; } index++; } return isMultiParamKey ? new MultipleParameterCacheKey(key) : new SingleParameterCacheKey(key); }; /** * @private * * @function getGetCacheKeyMethod * * @description * based on the options, get the getCacheKey method * * @param {Options} options the options passed to the moized method * @returns {function(Cache, Array&lt;*&gt;): CacheKey} the cache key */ export const getGetCacheKeyMethod = (options: Options): Function =&gt; { if (options.isReact) { return options.equals ? getReactCacheKeyCustomEquals : getReactCacheKey; } if (options.serialize) { return options.equals ? getSerializedCacheKeyCustomEquals : getSerializedCacheKey; } return options.equals ? getStandardCacheKeyCustomEquals : getStandardCacheKey; }; /** * @private * * @function createGetCacheKey * * @description * create the method that will get the cache key based on the options passed to the moized method * * @param {Cache} cache the cache to get the key from * @param {Options} options the options passed to the moized method * @returns {function(*): CacheKey} the method that will get the cache key */ export const createGetCacheKey = (cache: Cache, options: Options): Function =&gt; { const hasMaxArgs: boolean = isFiniteAndPositiveInteger(options.maxArgs); const getCacheKeyMethod: Function = getGetCacheKeyMethod(options); const shouldPassOptions: boolean = options.serialize || !!options.equals; if (shouldPassOptions) { if (hasMaxArgs) { const takeMaxArgs = take(options.maxArgs); return (key: any): CacheKey =&gt; { return getCacheKeyMethod(cache, takeMaxArgs(key), options); }; } return (key: any): CacheKey =&gt; { return getCacheKeyMethod(cache, key, options); }; } if (hasMaxArgs) { const takeMaxArgs = take(options.maxArgs); return (key: any): CacheKey =&gt; { return getCacheKeyMethod(cache, takeMaxArgs(key)); }; } return (key: any): CacheKey =&gt; { return getCacheKeyMethod(cache, key); }; }; /** * @private * * @function createSetNewCachedValue * * @description * assign the new value to the key in the functions cache and return the value * * @param {Cache} cache the cache to assign the value to at key * @param {Options} options the options passed to the moize method * @returns {function(function, *, *): *} value just stored in cache */ export const createSetNewCachedValue = ( cache: Cache, options: Options ): Function =&gt; { const hasMaxAge: boolean = isFiniteAndPositiveInteger(options.maxAge); const hasMaxSize: boolean = isFiniteAndPositiveInteger(options.maxSize); const {maxAge, maxSize} = options; if (options.isPromise) { if ( !isFunction(options.promiseLibrary) &amp;&amp; !isPlainObject(options.promiseLibrary) ) { throw new TypeError(INVALID_PROMISE_LIBRARY_ERROR); } return (key: any, value: any): Promise&lt;any&gt; =&gt; { const promiseResolver = createPromiseResolver( cache, key, hasMaxAge, options ); const promiseRejecter = createPromiseRejecter(cache, key, options); const handler = value.then(promiseResolver, promiseRejecter); cache.add(key, handler); if (hasMaxSize &amp;&amp; cache.size &gt; maxSize) { cache.remove(cache.list[cache.list.length - 1].key); } return handler; }; } return (key: any, value: any): any =&gt; { cache.add(key, value); if (hasMaxAge) { cache.expireAfter(key, maxAge); } if (hasMaxSize &amp;&amp; cache.size &gt; maxSize) { cache.remove(cache.list[cache.list.length - 1].key); } return value; }; }; /** * @private * * @function splice * * @description * faster version of splicing a single item from the array * * @param {Array&lt;*&gt;} array array to splice from * @param {number} startingIndex index to splice at * @returns {Array&lt;*&gt;} array minus the item removed */ export const splice = ( array: Array&lt;any&gt;, startingIndex: number ): Array&lt;any&gt; =&gt; { if (!array.length) { return array; } let index: number = startingIndex - 1; while (++index &lt; array.length) { array[index] = array[index + 1]; } array.length -= 1; return array; }; /** * @private * * @function unshift * * @description * faster version of unshifting a single item into an array * * @param {Array&lt;*&gt;} array array to unshift into * @param {*} item item to unshift into array * @returns {*} the item just added to the array */ export const unshift = (array: Array&lt;any&gt;, item: any): any =&gt; { let index: number = array.length; while (index--) { array[index + 1] = array[index]; } return (array[0] = item); }; /** * @private * * @function createAddPropertiesToFunction * * @description * add the static properties to the moized function * * @param {Cache} cache the cache for the moized function * @param {function} originalFunction the function to be moized * @param {Options} options the options passed to the moize method * @returns {function(function): function} the method which will add the static properties */ export const createAddPropertiesToFunction = ( cache: Cache, originalFunction: Function, options: Options ) =&gt; { const getCacheKey = createGetCacheKey(cache, options); return (moizedFunction: Function): Function =&gt; { moizedFunction.cache = cache; moizedFunction.displayName = `moize(${getFunctionName(originalFunction)})`; moizedFunction.isMoized = true; moizedFunction.options = options; moizedFunction.originalFunction = originalFunction; /** * @private * * @function add * * @description * manually add an item to cache if the key does not already exist * * @param {Array&lt;any&gt;} key key to use in cache * @param {*} value value to assign to key */ moizedFunction.add = (key: Array&lt;any&gt;, value: any) =&gt; { const internalKey = getCacheKey(key); if (!cache.has(internalKey)) { cache.add(internalKey, value); } }; /** * @private * * @function clear * * @description * clear the current cache for this method */ moizedFunction.clear = cache.clear; /** * @private * * @function has * * @description * does the function have cache for the specific args passed * * @param {Array&lt;*&gt;} key combination of args to remove from cache * @returns {boolean} does the cache for the give args exist */ moizedFunction.has = (key: Array&lt;any&gt;) =&gt; { return cache.has(getCacheKey(key)); }; /** * @private * * @function keys * * @description * get the list of keys currently in cache * * @returns {Array&lt;*&gt;} */ moizedFunction.keys = createPluckFromInstanceList(cache, 'key'); /** * @private * * @function remove * * @description * remove the item from cache for the key passed for this method * * @param {Array&lt;*&gt;} key combination of args to remove from cache */ moizedFunction.remove = (key: Array&lt;any&gt;) =&gt; { cache.remove(getCacheKey(key)); }; /** * @private * * @function values * * @description * get the list of values currently in cache * * @returns {Array&lt;*&gt;} */ moizedFunction.values = createPluckFromInstanceList(cache, 'value'); return addStaticPropertiesToFunction(originalFunction, moizedFunction); }; }; × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" moize Modules moize Global isMoized Source: index.js // @flow // cache import Cache from './Cache'; // constants import { INVALID_FIRST_PARAMETER_ERROR, PROMISE_OPTIONS, REACT_OPTIONS, SERIALIZE_OPTIONS } from './constants'; // types import type {Options} from './types'; // utils import { compose, createAddPropertiesToFunction, createCurriableOptionMethod, createGetCacheKey, createSetNewCachedValue, getDefaultedOptions, isFunction, isMoized, isPlainObject } from './utils'; /** * @module moize */ /** * @function moize * * @description * store cached values returned from calling method with arguments to avoid reprocessing data from same arguments * * @example * import moize from 'moize'; * * // standard implementation * const fn = (foo, bar) =&gt; { * return `${foo} ${bar}`; * }; * const memoizedFn = moize(fn); * * // implementation with options * const fn = async (id) =&gt; { * return get(`http://foo.com/${id}`); * }; * const memoizedFn = moize(fn, { * isPromise: true, * maxSize: 5 * }); * * @param {function} functionOrComposableOptions method to memoize * @param {Options} [passedOptions={}] options to customize how the caching is handled * @param {boolean} [passedOptions.isPromise=false] is the function return expected to be a promise to resolve * @param {number} [passedOptions.maxAge=Infinity] the maximum age the value should persist in cache * @param {number} [passedOptions.maxArgs=Infinity] the maximum number of arguments to be used in serializing the keys * @param {number} [passedOptions.maxSize=Infinity] the maximum size of the cache to retain * @param {function} [passedOptions.promiseLibrary=Promise] promise library to use for resolution / rejection * @param {function} [passedOptions.serializeFunctions=false] should function parameters be serialized as well * @param {function} [passedOptions.serializer] method to serialize arguments with for cache storage * @returns {Function} higher-order function which either returns from cache or newly-computed value */ const moize: Function = ( functionOrComposableOptions: Function | Object, passedOptions: Object = {} ): Function =&gt; { if (isPlainObject(functionOrComposableOptions)) { return function( fnOrOptions: Function | Object, otherOptions: Object = {} ): Function { if (isPlainObject(fnOrOptions)) { return moize({ // $FlowIgnore functionOrComposableOptions is object of options ...functionOrComposableOptions, // $FlowIgnore fnOrOptions is object of options ...fnOrOptions }); } return moize(fnOrOptions, { // $FlowIgnore functionOrComposableOptions is object of options ...functionOrComposableOptions, ...otherOptions }); }; } if (!isFunction(functionOrComposableOptions)) { throw new TypeError(INVALID_FIRST_PARAMETER_ERROR); } const isComposed: boolean = functionOrComposableOptions.isMoized; // $FlowIgnore if the function is already moized, it has an originalFunction property on it const fn: Function = isComposed ? functionOrComposableOptions.originalFunction : functionOrComposableOptions; const options: Options = getDefaultedOptions( !isComposed ? passedOptions : { ...functionOrComposableOptions.options, ...passedOptions } ); const cache: Cache = new Cache(); const addPropertiesToFunction: Function = createAddPropertiesToFunction( cache, fn, options ); const getCacheKey: Function = createGetCacheKey(cache, options); const setNewCachedValue: Function = createSetNewCachedValue(cache, options); const moizedFunction: Function = function(...args: Array&lt;any&gt;): any { const key: any = getCacheKey(args); return cache.size &amp;&amp; cache.has(key) ? cache.get(key) : setNewCachedValue(key, fn.apply(this, args)); }; return addPropertiesToFunction(moizedFunction); }; moize.compose = compose; moize.isMoized = isMoized; moize.maxAge = createCurriableOptionMethod(moize, 'maxAge'); moize.maxArgs = createCurriableOptionMethod(moize, 'maxArgs'); moize.maxSize = createCurriableOptionMethod(moize, 'maxSize'); moize.promise = moize(PROMISE_OPTIONS); moize.react = moize(REACT_OPTIONS); moize.reactSimple = compose(moize.react, moize.maxSize(1)); moize.serialize = moize(SERIALIZE_OPTIONS); moize.simple = moize.maxSize(1); export default moize; × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"MultipleParameterCacheKey.js.html":{"id":"MultipleParameterCacheKey.js.html","title":"Source: MultipleParameterCacheKey.js","body":" moize Modules moize Global isMoized Source: MultipleParameterCacheKey.js // @flow /** * @private * * @class MultipleParameterCacheKey * * @classdesc * cache key used when there are multiple standard parameters */ class MultipleParameterCacheKey { constructor(key: Array&lt;any&gt;) { this.key = key; this.size = key.length; return this; } isMultiParamKey: boolean = true; key: any = null; size: number = 0; /** * @function matches * @memberof MultipleParameterCacheKey * @instance * * @description * does the passed key match the key in the instance * * @param {Array&lt;*&gt;} key the key to test * @param {boolean} isMultiParamKey is the key a multi-parameter key * @returns {boolean} does the key passed match that in the instance */ matches(key: Array&lt;any&gt;, isMultiParamKey: boolean): boolean { if (!isMultiParamKey || key.length !== this.size) { return false; } let index: number = 0; while (index &lt; this.size) { if (key[index] !== this.key[index]) { return false; } index++; } return true; } /** * @function matchesCustom * @memberof SingleParameterCacheKey * @instance * * @description * does the passed key match the key in the instance based on the custom equality function passed * * @param {Array&lt;*&gt;} key the key to test * @param {boolean} isMultiParamKey is the key a multi-parameter key * @param {function} isEqual method to compare equality of the keys * @returns {boolean} does the key passed match that in the instance */ matchesCustom( key: Array&lt;any&gt;, isMultiParamKey: boolean, isEqual: Function ): boolean { if (!isMultiParamKey || key.length !== this.size) { return false; } let index: number = 0; while (index &lt; this.size) { if (!isEqual(key[index], this.key[index])) { return false; } index++; } return true; } } export default MultipleParameterCacheKey; × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"ReactCacheKey.js.html":{"id":"ReactCacheKey.js.html","title":"Source: ReactCacheKey.js","body":" moize Modules moize Global isMoized Source: ReactCacheKey.js // @flow /** * @private * * @class ReactCacheKey * * @classdesc * cache key used specifically for react components */ class ReactCacheKey { constructor(key: Array&lt;Object&gt;) { const context = key[1]; const props = key[0]; this.key = { context, contextSize: context ? Object.keys(context).length : 0, props, propsSize: props ? Object.keys(props).length : 0 }; return this; } key: any = null; /** * @function _isPropShallowEqual * @memberof ReactCacheKey * @instance * * @description * check if the prop value passed is equal to the key's value * * @param {string} prop the key property to test * @param {Object} object the value of the key to test against * @returns {boolean} is the prop value shallow equal to the object */ _isPropShallowEqual(prop: string, object: Object): boolean { const keys: Array&lt;string&gt; = Object.keys(object); if (keys.length !== this.key[`${prop}Size`]) { return false; } let index: number = 0; while (index &lt; keys.length) { if (object[keys[index]] !== this.key[prop][keys[index]]) { return false; } index++; } return true; } /** * @function _isPropCustomEqual * @memberof ReactCacheKey * @instance * * @description * check if the prop value passed is equal to the key's value * * @param {string} prop the key property to test * @param {Object} object the value of the key to test against * @param {function} isEqual method to check equality of keys * @returns {boolean} is the prop value shallow equal to the object */ _isPropCustomEqual(prop: string, object: Object, isEqual: Function): boolean { const keys: Array&lt;string&gt; = Object.keys(object); if (keys.length !== this.key[`${prop}Size`]) { return false; } let index: number = 0; while (index &lt; keys.length) { if (!isEqual(object[keys[index]], this.key[prop][keys[index]])) { return false; } index++; } return true; } /** * @function matches * @memberof ReactCacheKey * @instance * * @description * does the passed key match the key in the instance * * @param {Array&lt;*&gt;} key the key to test * @returns {boolean} does the key passed match that in the instance */ matches(key: Array&lt;Object&gt;): boolean { return ( this._isPropShallowEqual('props', key[0]) &amp;&amp; this._isPropShallowEqual('context', key[1]) ); } /** * @function matchesCustom * @memberof ReactCacheKey * @instance * * @description * does the passed key match the key in the instance * * @param {Array&lt;*&gt;} key the key to test * @param {function} isEqual method to check equality of keys * @returns {boolean} does the key passed match that in the instance */ matchesCustom(key: Array&lt;Object&gt;, isEqual: Function): boolean { return ( this._isPropCustomEqual('props', key[0], isEqual) &amp;&amp; this._isPropCustomEqual('context', key[1], isEqual) ); } } export default ReactCacheKey; × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"SerializedCacheKey.js.html":{"id":"SerializedCacheKey.js.html","title":"Source: SerializedCacheKey.js","body":" moize Modules moize Global isMoized Source: SerializedCacheKey.js // @flow /** * @private * * @class SerializedCacheKey * * @classdesc * cache key used when the parameters should be serialized */ class SerializedCacheKey { constructor(key: Array&lt;any&gt;) { this.key = key; return this; } key: any = null; /** * @function matches * @memberof SerializedCacheKey * @instance * * @description * does the passed key match the key in the instance *W * @param {Array&lt;*&gt;} key the key to test * @returns {boolean} does the key passed match that in the instance */ matches(key: Array&lt;any&gt;): boolean { return key === this.key; } /** * @function matchesCustom * @memberof SerializedCacheKey * @instance * * @description * does the passed key match the key in the instance based on the custom equality function passed * * @param {Array&lt;*&gt;} key the key to test * @param {function} isEqual method to compare equality of the keys * @returns {boolean} does the key passed match that in the instance */ matchesCustom(key: Array&lt;any&gt;, isEqual: Function): boolean { return isEqual(key, this.key); } } export default SerializedCacheKey; × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"SingleParameterCacheKey.js.html":{"id":"SingleParameterCacheKey.js.html","title":"Source: SingleParameterCacheKey.js","body":" moize Modules moize Global isMoized Source: SingleParameterCacheKey.js // @flow /** * @private * * @class SingleParameterCacheKey * * @classdesc * cache key used when there is a single standard parameter */ class SingleParameterCacheKey { constructor(key: Array&lt;any&gt;) { this.key = key[0]; return this; } isMultiParamKey: boolean = false; key: any = null; /** * @function matches * @memberof SingleParameterCacheKey * @instance * * @description * does the passed key match the key in the instance * * @param {Array&lt;*&gt;} key the key to test * @param {boolean} isMultiParamKey is the key a multi-parameter key * @returns {boolean} does the key passed match that in the instance */ matches(key: Array&lt;any&gt;, isMultiParamKey: boolean): boolean { return !isMultiParamKey &amp;&amp; key[0] === this.key; } /** * @function matchesCustom * @memberof SingleParameterCacheKey * @instance * * @description * does the passed key match the key in the instance based on the custom equality function passed * * @param {Array&lt;*&gt;} key the key to test * @param {boolean} isMultiParamKey is the key a multi-parameter key * @param {function} isEqual method to compare equality of the keys * @returns {boolean} does the key passed match that in the instance */ matchesCustom( key: Array&lt;any&gt;, isMultiParamKey: boolean, isEqual: Function ): boolean { return !isMultiParamKey &amp;&amp; isEqual(key[0], this.key); } } export default SingleParameterCacheKey; × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"global.html":{"id":"global.html","title":"Global","body":" moize Modules moize Global isMoized Global Methods isMoized(fn) is the function passed a moized function or not Parameters: Name Type Description fn * the function to get if moize Source: utils.js, line 96 Returns: is the function moized or not Type boolean × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" moize Modules moize Global isMoized Modules × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" moize Modules moize Global isMoized moize 3.1.0 moize moize is a blazing fast memoization library for JavaScript. It handles multiple parameters (including default values) without any additional configuration, and offers options to help satisfy a number of implementation-specific needs. It has no dependencies, and is ~3.4kb when minified and gzipped. Table of contents Upgrade notification Installation Usage Advanced usage equals isPromise isReact maxAge maxArgs maxSize promiseLibrary serialize serializeFunctions serializer Usage with shortcut methods moize.maxAge moize.maxArgs moize.maxSize moize.promise moize.react moize.reactSimple moize.serialize moize.simple Composition Introspection isMoized Benchmarks Single parameter Multiple parameters (primitives only) Multiple parameters (complex objects) Direct cache manipulation add clear has keys remove values Browser support Development Upgrade notification Users of moize 2.x.x may experience breaking changes, especially if using a custom cache or using moize.react in a mutative way. Please see the changelog for more details about how to manage the upgrade. Installation $ npm i moize --saveUsage import moize from 'moize'; const method = (a, b) =&gt; { return a + b; }; const memoized = moize(method); memoized(2, 4); // 6 memoized(2, 4); // 6, pulled from cacheAll parameter types are supported, including circular objects, functions, etc. There are also a number of shortcut methods to easily create memoization for targeted use-cases. You can even memoize functional React components based on their props + context combination (see the isReact option, or the moize.react shortcut method)! Advanced usage moize optionally accepts an object of options as either the second parameter or as the first step in a curried function: // inline moize(fn, options); // curried moize(options)(fn);The full shape of these options: { equals: Function, // custom method to compare equality between two objects isPromise: boolean, // is the result a promise isReact: boolean, // is the result a React component maxAge: number, // amount of time in milliseconds before the cache will expire maxArgs: number, // maximum number of arguments to use as key for caching maxSize: number, // maximum size of cache for this method promiseLibrary: Function|Object, // promise library to use when isPromise is true, if not using native promises serialize: boolean, // should the parameters be serialized instead of directly referenced serializeFunctions: boolean, // should functions be included in the serialization of multiple parameters serializer: Function // method to serialize the arguments to build a unique cache key }equals defaults to strict equality Custom method used to compare equality of keys for cache purposes. // using lodash's deep equal comparison method import isEqual from 'lodash/isEqual'; const fn = ({foo, bar}) =&gt; { return [foo, bar]; }; const memoized = moize(fn, { equals: isEqual }); memoized({foo: 'foo', bar: 'bar'}); memoized({foo: 'foo', bar: 'bar'}); // pulls from cacheThe equals method receives two parameters (cache key values) and should return a boolean. Please note that this will be slower than the default strict equality comparison, however how much slower is based on the efficiency of the method passed. isPromise defaults to false Is the computed value in the function a Promise, and should we cache the resolved value from that Promise. This is also available via the shortcut method of moize.promise. const fn = async (item) =&gt; { return await item; }; const memoized = moize(fn, { isPromise: true });The resolved value of the Promise will be stored in cache as a Promise itself, so that cached returns will always be in the form of a Promise. For common usage reasons, if the Promise is rejected, the cache entry will be deleted. Also, if a maxAge is provided, the countdown of that TTL will begin upon the resolution of the promise rather than at the instantiation of it. isReact defaults to false Is the function passed a stateless functional React component. This is also available via the shortcut method of moize.react. const Foo = ({bar, baz}) =&gt; { return ( &lt;div&gt; {bar}: {baz} &lt;/div&gt; ); }; export default moize(Foo, { isReact: true });The method will do a shallow comparison of both props and context of the component based on strict equality. If you have mutative props and instead want to do a deep equals comparison, provide a custom equals option. maxAge defaults to Infinity The maximum amount of time in milliseconds that you want a computed value to be stored in cache for this method. This is also available via the shortcut method of moize.maxAge. const fn = (item) =&gt; { return item; }; const memoized = moize(fn, { maxAge: 1000 * 60 * 5 // five minutes });maxArgs defaults to the length of arguments passed to the method The maximum number of arguments used in creating the key for the cache. This is also available via the shortcut method of moize.maxArgs. const fn = (item1, item2, item3) =&gt; { return item1 + item2 + item3; }; const memoized = moize(fn, { maxArgs: 2 }); memoize('foo', 'bar', 'baz'); memoize('foo', 'bar', 'quz'); // pulls from cache, as the first two args are the samemaxSize defaults to Infinity The maximum number of values you want stored in cache for this method. Clearance of the cache once the maxSize is reached is on a Least Recently Used basis. This is also available via the shortcut method of moize.maxSize. const fn = (item) =&gt; { return item; }; const memoized = moize(fn, { maxSize: 5 });promiseLibrary defaults to native Promise The promise library to use for resolution / rejection of promises. const fn = (foo) =&gt; { return new Bluebird((resolve) =&gt; { resolve(foo); }); }; const memoized = moize(fn, { isPromise: true, promiseLibrary: Bluebird });Please note that for this option to work isPromise must be set to true. You can use any library where the following aspects of the specification are included: It is thenable (the generated promise has a .then() function) The Promise object itself has .resolve() and .reject() functions on it Most modern libraries (bluebird, q, etc.) include these by default, however if you are using a custom library that does not meet these requirements then you will need to implement them yourself. An example of a wrapper that creates the .resolve() and .reject() methods: import foo from 'my-promise-library'; // create a wrapper so as not to touch the library itself const customPromise = (fn) =&gt; { return foo(fn); }; // lets pretend foo has a .result() method that has the first // parameter as successful, second as failure customPromise.resolve = function(value) { return foo.result(value); }; customPromise.reject = function(error) { return foo.result(undefined, error); }; const fn = (foo) =&gt; { return customPromise((resolve) =&gt; { resolve(foo); }); }; const memoized = moize(fn, { isPromise: true, promiseLibrary: customPromise });serialize defaults to false Serializes the parameters passed into a string and uses this as the key for cache comparison. This is also available via the shortcut method of moize.serialize. const fn = (mutableObject) =&gt; { return mutableObject.foo; }; const memoized = moize(fn, { serialize: true }); const object = { foo: 'foo' }; memoized(object); // 'foo' object.foo = 'bar'; memoized(object); // 'bar'Please note that this is slower than the default key storage (see benchmarks). serializeFunctions defaults to false A custom replacer is used when serializing to ensure functions are included in the key serialization. const FunctionalComponent = ({onClickFoo}) =&gt; { return ( &lt;button onClick={onClickFoo} type=&quot;button&quot; &gt; Click me! &lt;/button&gt; ) }; const MemoizedFunctionalComponent = moize(FunctionalComponent, { serialize: true, serializeFunctions: true });Please note that you must also set serialize to true for this setting to take effect. serializer defaults to serializeArguments in utils.js Overrides the internal serializer when serializing the parameters for cache key comparison. The value returned from the function must be a valid value of keys for a Map; it does not need to a string, but should be unique from a strict equality perspective. const serializer = (args) =&gt; { return JSON.stringify(args[0]); }; const memoized = moize(fn, { serialize: true, serializer });Please note that you must also set serialize to true for this setting to take effect. Usage with shortcut methods moize.maxAge Pre-applies the maxAge option as a curriable method. import moize from 'moize'; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.maxAge(5000)(foo);moize.maxArgs Pre-applies the maxArgs option as a curriable method. import moize from 'moize'; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.maxArgs(1)(foo);moize.maxSize Pre-applies the maxSize option as a curriable method. import moize from 'moize'; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.maxSize(5)(foo);moize.promise Pre-applies the isPromise option. import moize from 'moize'; const foo = async (bar, baz) =&gt; { return await someApiCall(bar, baz); }; export default moize.promise(foo);Please note that if you want to provide a custom promiseLibrary, you must do so with additional options: const additionalOptions = { promiseLibrary: Bluebird }; moize.promise(fn, additionalOptions); // or moize.promise(additionalOptions)(fn);moize.react Shortcut for memoizing functional components in React. This uses a special cache key that will do a shallow equal comparison of changes to both props and context. import moize from 'moize'; const Foo = ({bar, baz}) =&gt; { return ( &lt;div&gt; {bar} {baz} &lt;/div&gt; ); }; export default moize.react(Foo);Also, it should be noted that in usages that involve a lot of variety in the parameter changes, this has the potential for excessive memory consumption, as the cache will retain the history of all elements. It is therefore recommended to apply a maxSize, or to use the shortcut method moize.reactSimple, which automatically sets the maxSize to 1. Please note moize.react will not operate with components made via the class instantiation, as they do not offer the same referential transparency. moize.reactSimple Shortcut for memoizing functional components in React, with the cache size limited to a single entry. This mimics the PureComponent optimization, where the cache will only contain the component with the most recent props and context combination. import moize from 'moize'; const Foo = ({bar, baz}) =&gt; { return ( &lt;div&gt; {bar} {baz} &lt;/div&gt; ); }; export default moize.reactSimple(Foo);Please note moize.reactSimple will not operate with components made via the class instantiation, as they do not offer the same referential transparency. moize.serialize Pre-applies the serialize option. import moize from 'moize'; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.serialize(foo);Please note that if you want to serializeFunctions or provide a custom serializer, you must do so with additional options: const additionalOptions = { serializeFunctions: true }; moize.serialize(fn, additionalOptions); // or moize.serialize(additionalOptions)(fn);moize.simple Pre-applies the maxSize option with 1. import moize from 'moize'; const foo = (bar, baz) =&gt; { return `${bar} ${baz}`; }; export default moize.simple(foo);Composition Starting with version 2.3.0, you can compose moize methods. This will create a new memoized method with the original function that shallowly merges the options of the two setups. Example: import moize from 'moize'; const Foo = (props) =&gt; { return ( &lt;div {...props}/&gt; ); }; // memoizing with react, as since 2.0.0 const MemoizedFoo = moize.react(Foo); // creating a separately-memoized method that has maxSize of 5 const LastFiveFoo = moize.maxSize(5)(MemoizedFoo);You can also create an options-first curriable version of moize if you only pass the options: import moize from 'moize'; // creates a function that will memoize what is passed const limitedSerializedMoize = moize({ maxSize: 5, serialize: true }); const foo = (bird) =&gt; { return `${bird} is the word`; }; const moizedFoo = limitedSerializedMoize(foo);You can also combine all of these options with moize.compose to create moize wrappers with pre-defined options. import moize from 'moize'; // creates a moizer that will have the options of // {isReact: true, maxAge: 5000, maxSize: 5} const superLimitedReactMoize = moize.compose(moize.react, moize.maxSize(5), moize.maxAge(5000));introspection There currently is only one method to introspect objects specific to moize, but if you want more just ask! isMoized Is the function passed a moized function. const fn = () =&gt; {}; const moizedFn = moize(fn); moize.isMoized(fn); // false moize.isMoized(moizedFn); // trueBenchmarks All values provided are the number of operations per second (ops/sec) calculated by the Benchmark suite. Note that underscore, lodash, and ramda do not support mulitple-parameter memoization, so they are not included in those benchmarks. Each benchmark was performed using the default configuration of the library, with a fibonacci calculation based on a starting parameter of 35, and in the case of multiple parameters a second parameter (boolean for primitives, object for complex objects) was used. Single parameter Operations / second Relative margin of error moize 44,547,124 0.64% fast-memoize 30,048,291 0.97% moize (serialized) 14,877,726 0.63% underscore 13,821,853 0.61% memoizee 11,494,292 0.90% lodash 10,020,324 0.52% lru-memoize 10,017,832 1.30% Addy Osmani 4,423,578 0.76% memoizerific 2,174,503 1.31% ramda 1,171,053 0.71% Multiple parameters (primitives only) Operations / second Relative margin of error moize 24,947,214 0.77% moize (serialized) 10,982,454 0.84% memoizee 8,602,634 0.59% lru-memoize 7,667,460 1.58% Addy Osmani 2,039,761 0.86% memoizerific 1,336,321 0.81% fast-memoize 844,633 0.76% Multiple parameters (complex objects) Operations / second Relative margin of error moize 24,146,198 1.16% memoizee 8,324,025 0.86% lru-memoize 7,986,555 1.15% moize (serialized) 1,798,895 0.95% memoizerific 1,416,617 1.15% Addy Osmani 1,097,775 0.78% fast-memoize 746,371 1.03% Direct cache manipulation There are a few methods provided on the moized function which allow for programmatic manipulation of the cache: add(key, value) This will manually add the value at key in cache if key does not already exist. key is an Array of values, meant to reflect the arguments passed to the method. // single parameter is straightforward const memoized = moize((item) =&gt; { return item; }); memoized.add(['foo'], 'bar'); // pulls from cache memoized('foo');clear() This will clear all values in the cache, resetting it to an empty state. const memoized = moize((item) =&gt; { return item; }); memoized.clear();has(key) This will return true if a cache entry exists for the key passed, else will return false. key is an Array of values, meant to reflect the arguments passed to the method. const memoized = moize((first, second) =&gt; { return [first, second]; }); memoized('foo', 'bar'); console.log(memoized.has(['foo', 'bar'])); // true console.log(memoized.has(['bar', 'baz'])); // falsekeys() This will return a list of the current keys in cache. const memoized = moize((item) =&gt; { return item; }); const foo = 'foo'; memoized(foo); const bar = { baz: 'baz' }; memoized(bar); const keys = memoized.keys(); // ['foo', {baz: 'baz'}]remove(key) This will remove the provided key from cache. key is an Array of values, meant to reflect the arguments passed to the method. const memoized = moize((item) =&gt; { return item; }); const foo = { bar: 'baz' }; memoized(foo); memoized.remove([foo]); // will re-execute, as it is no longer in cache memoized(foo);values() This will return a list of the current values in cache when the native Cache. const memoized = moize((item) =&gt; { return { item }; }); const foo = 'foo'; memoized(foo); const bar = { baz: 'baz' }; memoized(bar); const values = memoized.values(); // [{item: 'foo'}, {item: {baz: 'baz'}}]Browser support Chrome (all versions) Firefox (all versions) Edge (all versions) Opera 15+ IE 9+ Safari 6+ iOS 8+ Android 4+ Development Standard stuff, clone the repo and npm install dependencies. The npm scripts available: build =&gt; run webpack to build development dist file with NODE_ENV=development build:minifed =&gt; run webpack to build production dist file with NODE_ENV=production dev =&gt; run webpack dev server to run example app (playground!) dist =&gt; runs build and build-minified docs =&gt; builds the docs via jsdoc lint =&gt; run ESLint against all files in the src folder prepublish =&gt; runs compile-for-publish prepublish:compile =&gt; run lint, test, transpile, dist test =&gt; run AVA test functions with NODE_ENV=test test:coverage =&gt; run test but with nyc for coverage checker test:watch =&gt; run test, but with persistent watcher transpile =&gt; run babel against all files in src to create files in lib × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "},"module-moize.html":{"id":"module-moize.html","title":"Module: moize","body":" moize Modules moize Global isMoized Module: moize Source: index.js, line 29 Methods &lt;inner&gt; moize(functionOrComposableOptions [, passedOptions]) store cached values returned from calling method with arguments to avoid reprocessing data from same arguments Parameters: Name Type Argument Default Description functionOrComposableOptions function method to memoize passedOptions Options &lt;optional&gt; {} options to customize how the caching is handled Properties Name Type Argument Default Description isPromise boolean &lt;optional&gt; false is the function return expected to be a promise to resolve maxAge number &lt;optional&gt; Infinity the maximum age the value should persist in cache maxArgs number &lt;optional&gt; Infinity the maximum number of arguments to be used in serializing the keys maxSize number &lt;optional&gt; Infinity the maximum size of the cache to retain promiseLibrary function &lt;optional&gt; Promise promise library to use for resolution / rejection serializeFunctions function &lt;optional&gt; false should function parameters be serialized as well serializer function &lt;optional&gt; method to serialize arguments with for cache storage Source: index.js, line 33 Returns: higher-order function which either returns from cache or newly-computed value Type function Example import moize from 'moize'; // standard implementation const fn = (foo, bar) =&gt; { return `${foo} ${bar}`; }; const memoizedFn = moize(fn); // implementation with options const fn = async (id) =&gt; { return get(`http://foo.com/${id}`); }; const memoizedFn = moize(fn, { isPromise: true, maxSize: 5 }); × Search results Close Documentation generated by JSDoc 3.5.3 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
