<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>moize Index</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.dark.css">

	<link type="text/css" rel="stylesheet" href="styles/site.paper.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top ">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">moize</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="modules.list.html" class="dropdown-toggle" data-toggle="dropdown">Modules<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="module-moize.html">moize</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-8">
	
		<div id="main">
			

	
	



    <h3>moize 5.3.1</h3>









	
	





    <section class="readme-section">
        <article><h1 id="moize">moize</h1>
<p><img src="https://img.shields.io/badge/build-passing-brightgreen.svg"/>
<img src="https://img.shields.io/badge/coverage-100%25-brightgreen.svg"/>
<img src="https://img.shields.io/badge/license-MIT-blue.svg"/></p>
<p><code>moize</code> is a <a href="#benchmarks">consistently blazing fast</a> memoization library for JavaScript. It handles multiple parameters (including default values) without any additional configuration, and offers a large number of options to satisfy any number of potential use-cases.</p>
<h2 id="table-of-contents">Table of contents</h2>
<ul>
<li><a href="#installation">Installation</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#configuration-options">Configuration options</a><ul>
<li><a href="#equals">equals</a></li>
<li><a href="#isdeepequal">isDeepEqual</a></li>
<li><a href="#ispromise">isPromise</a></li>
<li><a href="#isreact">isReact</a></li>
<li><a href="#isserialized">isSerialized</a></li>
<li><a href="#matcheskey">matchesKey</a></li>
<li><a href="#maxage">maxAge</a></li>
<li><a href="#maxargs">maxArgs</a></li>
<li><a href="#maxsize">maxSize</a></li>
<li><a href="#oncacheadd">onCacheAdd</a></li>
<li><a href="#oncachechange">onCacheChange</a></li>
<li><a href="#oncachehit">onCacheHit</a></li>
<li><a href="#onexpire">onExpire</a></li>
<li><a href="#profilename">profileName</a></li>
<li><a href="#serializefunctions">shouldSerializeFunctions</a></li>
<li><a href="#serializer">serializer</a></li>
<li><a href="#transformargs">transformArgs</a></li>
<li><a href="#updateexpire">updateExpire</a></li>
</ul>
</li>
<li><a href="#usage-with-shortcut-methods">Usage with shortcut methods</a><ul>
<li><a href="#moizedeep">moize.deep</a></li>
<li><a href="#moizemaxage">moize.maxAge</a></li>
<li><a href="#moizemaxargs">moize.maxArgs</a></li>
<li><a href="#moizemaxsize">moize.maxSize</a></li>
<li><a href="#moizepromise">moize.promise</a></li>
<li><a href="#moizereact">moize.react</a></li>
<li><a href="#moizereactsimple">moize.reactSimple</a></li>
<li><a href="#moizeserialize">moize.serialize</a></li>
<li><a href="#moizesimple">moize.simple</a></li>
</ul>
</li>
<li><a href="#composition">Composition</a></li>
<li><a href="#introspection">Introspection</a><ul>
<li><a href="#getstatsprofilename">getStats</a></li>
<li><a href="#iscollectingstats">isCollectingStats</a></li>
<li><a href="#ismoized">isMoized</a></li>
</ul>
</li>
<li><a href="#collecting-statistics">Collecting statistics</a></li>
<li><a href="#direct-cache-manipulation">Direct cache manipulation</a><ul>
<li><a href="#cache">cache</a></li>
<li><a href="#cachesnapshot">cacheSnapshot</a></li>
<li><a href="#addkey-value">add</a></li>
<li><a href="#clear">clear</a></li>
<li><a href="#getkey">get</a></li>
<li><a href="#getstats">getStats</a></li>
<li><a href="#hasargs">has</a></li>
<li><a href="#keys">keys</a></li>
<li><a href="#removekey">remove</a></li>
<li><a href="#updatekey-value">update</a></li>
<li><a href="#values">values</a></li>
</ul>
</li>
<li><a href="#benchmarks">Benchmarks</a></li>
<li><a href="#filesize">Filesize</a></li>
<li><a href="#browser-support">Browser support</a></li>
<li><a href="#development">Development</a></li>
</ul>
<h2 id="installation">Installation</h2>
<pre class="prettyprint source"><code>$ npm i moize --save</code></pre><h2 id="usage">Usage</h2>
<pre class="prettyprint source lang-javascript"><code>import moize from &quot;moize&quot;;

const method = (a, b) => {
  return a + b;
};

const memoized = moize(method);

memoized(2, 4); // 6
memoized(2, 4); // 6, pulled from cache</code></pre><p>All parameter types are supported, including circular objects, functions, etc. There are also a number of <a href="#usage-with-shortcut-methods">shortcut methods</a> to memoize for unique use-cases.</p>
<h2 id="configuration-options">Configuration options</h2>
<p><code>moize</code> optionally accepts an object of options as either the second parameter or as the first step in a curried function:</p>
<pre class="prettyprint source lang-javascript"><code>// inline
moize(fn, options);

// curried
moize(options)(fn);</code></pre><p>The full shape of these options:</p>
<pre class="prettyprint source lang-javascript"><code>{
  equals: Function, // custom method to compare equality between two objects
  isDeepEqual: boolean, // is the cache based on deep equality of keys
  isPromise: boolean, // is the result a promise
  isReact: boolean, // is the result a React component
  isSerialized: boolean, // should the parameters be serialized instead of directly referenced
  maxAge: number, // amount of time in milliseconds before the cache will expire
  maxArgs: number, // maximum number of arguments to use as key for caching
  maxSize: number, // maximum size of cache for this method
  onCacheAdd: Function, // method fired when a new entry is added to cache
  onCacheChange: Function, // method fire when either a new entry is added to cache or the LRU ordering of the cache has changed
  onCacheHit: Function, // method fired when an existing entry in cache is used
  onExpire: Function, // method to fire when a cache entry expires (in combination with maxAge)
  profileName: string, // the unique identifier to give the memoized method when collecting statistics
  shouldSerializeFunctions: boolean, // should functions be included in the serialization of multiple parameters
  serializer: Function, // method to serialize the arguments to build a unique cache key
  transformArgs: Function, // method to transform the args into a custom format for key storage in cache
  updateExpire: boolean // should the cache entry's expiration be refreshed when the cache entry is hit (in combination with maxAge)
}</code></pre><h4 id="equals">equals</h4>
<p><em>defaults to <a href="http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero">SameValueZero</a> equality</em></p>
<p>Custom method used to compare equality of keys for cache purposes by comparing each argument.</p>
<pre class="prettyprint source lang-javascript"><code>// using lodash's deep equal comparison method
const fn = ({ foo, bar }) => {
  return [foo, bar];
};

const memoized = moize(fn, {
  equals(cacheKeyArgument, keyArgument) {
    return cacheKeyArgument.foo === &quot;bar&quot; && keyArgument.foo === &quot;bar&quot;;
  }
});

memoized({ foo: &quot;bar&quot; });
memoized({ foo: &quot;bar&quot;, bar: &quot;baz&quot; }); // pulls from cache</code></pre><p>The <code>equals</code> method receives two parameters (cache key arguments) and should return a <code>boolean</code>.</p>
<p><strong>NOTE</strong>: This comparison is used iteratively on each argument, rather than comparing the two keys as a whole. If you want to compare the key as a whole, you should use <a href="#matcheskey"><code>matchesKey</code></a>.</p>
<h4 id="isdeepequal">isDeepEqual</h4>
<p><em>defaults to false</em></p>
<p>Should deep equality be used to compare cache keys. This is also available via the shortcut method of <a href="#moizedeep"><code>moize.deep</code></a></p>
<pre class="prettyprint source lang-javascript"><code>const fn = ({ foo, bar }) => {
  return [foo, bar];
};

const memoized = moize(fn, {
  isDeepEqual: true
});

memoized({ foo: &quot;foo&quot;, bar: &quot;bar&quot; });
memoized({ foo: &quot;foo&quot;, bar: &quot;bar&quot; }); // pulls from cache</code></pre><h4 id="ispromise">isPromise</h4>
<p><em>defaults to false</em></p>
<p>Is the computed value in the function a <code>Promise</code>. This is also available via the shortcut method of <a href="#moizepromise"><code>moize.promise</code></a>.</p>
<pre class="prettyprint source lang-javascript"><code>const fn = async item => {
  return await item;
};

const memoized = moize(fn, {
  isPromise: true
});</code></pre><p>The <code>Promise</code> itself will be stored in cache, so that cached returns will always maintain the <code>Promise</code> contract. For common usage reasons, if the <code>Promise</code> is rejected, the cache entry will be deleted.</p>
<h4 id="isreact">isReact</h4>
<p><em>defaults to false</em></p>
<p>Is the function passed a stateless functional <code>React</code> component. This is also available via the shortcut method of <a href="#moizereact"><code>moize.react</code></a>.</p>
<pre class="prettyprint source lang-javascript"><code>const Foo = ({ bar, baz }) => {
  return (
    &lt;div>
      {bar}: {baz}
    &lt;/div>
  );
};

export default moize(Foo, {
  isReact: true
});</code></pre><p>The method will do a shallow equal comparison of both <code>props</code> and <code>context</code> of the component based on strict equality. If you want to do a deep equals comparison, set <a href="#isdeepequal"><code>isDeepEqual</code></a> to true.</p>
<h4 id="isserialized">isSerialized</h4>
<p><em>defaults to false</em></p>
<p>Serializes the parameters passed into a string and uses this as the key for cache comparison. This is also available via the shortcut method of <a href="#moizeserialize"><code>moize.serialize</code></a>.</p>
<pre class="prettyprint source lang-javascript"><code>const fn = mutableObject => {
  return mutableObject.foo;
};

const memoized = moize(fn, {
  isSerialized: true
});

const object = {
  foo: &quot;foo&quot;
};

memoized(object); // 'foo'

object.foo = &quot;bar&quot;;

memoized(object); // 'bar'</code></pre><p>If <code>serialize</code> is combined with either <code>maxArgs</code> or <code>transformArgs</code>, the following order is used:</p>
<ol>
<li>limit by <code>maxArgs</code> (if applicable)</li>
<li>transform by <code>transformArgs</code> (if applicable)</li>
<li>serialize by <code>serializer</code></li>
</ol>
<p><strong>NOTE</strong>: This is much slower than the default key storage, and usually the same requirements can be meet with <code>isDeepEqual</code>, so use at your discretion.</p>
<h4 id="matcheskey">matchesKey</h4>
<p>Custom method used to compare equality of keys for cache purposes by comparing the entire key.</p>
<pre class="prettyprint source lang-javascript"><code>// using lodash's deep equal comparison method
const fn = ({ foo, bar }) => {
  return [foo, bar];
};

const memoized = moize(fn, {
  matchesKey(cacheKey, key) {
    return (
      cacheKey[0].foo === key[0].foo &&
      cacheKey[1].hasOwnProperty(&quot;bar&quot;) &&
      key[1].hasOwnProperty(&quot;bar&quot;)
    );
  }
});

memoized({ foo: &quot;bar&quot; }, { bar: null });
memoized({ foo: &quot;bar&quot; }, { bar: &quot;baz&quot; }); // pulls from cache</code></pre><p>The <code>matchesKey</code> method receives two parameters (cache keys) and should return a <code>boolean</code>.</p>
<p><strong>NOTE</strong>: This comparison uses the two keys as a whole, which is usually less performant than the <code>equals</code> comparison used iteratively on each argument. Generally speaking you should use the <a href="#equals"><code>equals</code></a> option for equality comparison.</p>
<h4 id="maxage">maxAge</h4>
<p>The maximum amount of time in milliseconds that you want a computed value to be stored in cache for this method. This is also available via the shortcut method of <a href="#moizemaxage"><code>moize.maxAge</code></a>.</p>
<pre class="prettyprint source lang-javascript"><code>const fn = item => {
  return item;
};

const memoized = moize(fn, {
  maxAge: 1000 * 60 * 5 // five minutes
});</code></pre><p><strong>TIP</strong>: A common usage of this is in tandom with <code>isPromise</code> for AJAX calls, and in that scenario the expected behavior is usually to have the <code>maxAge</code> countdown begin upon resolution of the promise. If this is your intended use case, you should also apply the <code>updateExpire</code> option.</p>
<h4 id="maxargs">maxArgs</h4>
<p>The maximum number of arguments (starting from the first) used in creating the key for the cache. This is also available via the shortcut method of <a href="#moizemaxargs"><code>moize.maxArgs</code></a>.</p>
<pre class="prettyprint source lang-javascript"><code>const fn = (item1, item2, item3) => {
  return item1 + item2 + item3;
};

const memoized = moize(fn, {
  maxArgs: 2
});

memoize(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;);
memoize(&quot;foo&quot;, &quot;bar&quot;, &quot;quz&quot;); // pulls from cache, as the first two args are the same</code></pre><p>If <code>maxArgs</code> is combined with either <code>serialize</code> or <code>transformArgs</code>, the following order is used:</p>
<ol>
<li>limit by <code>maxArgs</code></li>
<li>transform by <code>transformArgs</code> (if applicable)</li>
<li>serialize by <code>serializer</code> (if applicable)</li>
</ol>
<h4 id="maxsize">maxSize</h4>
<p><em>defaults to Infinity</em></p>
<p>The maximum number of values you want stored in cache for this method. Clearance of the cache once the <code>maxSize</code> is reached is on a <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_Recently_Used_.28LRU.29">Least Recently Used</a> basis. This is also available via the shortcut method of <a href="#moizemaxsize"><code>moize.maxSize</code></a>.</p>
<pre class="prettyprint source lang-javascript"><code>const fn = item => {
  return item;
};

const memoized = moize(fn, {
  maxSize: 5
});</code></pre><h4 id="oncacheadd">onCacheAdd</h4>
<p>Method to fire when an item has been added to cache. Receives the cache, options, and memoized function as a parameters.</p>
<pre class="prettyprint source lang-javascript"><code>const fn = (foo, bar) => {
  return [foo, bar];
};

const moized = moize(fn, {
  onCacheAdd(cache, options, moized) {
    console.log(cache.keys);
  }
});

moized(&quot;foo&quot;, &quot;bar&quot;); // [[&quot;foo&quot;,&quot;bar&quot;]]
moized(&quot;foo&quot;, &quot;bar&quot;);
moized(&quot;bar&quot;, &quot;foo&quot;); // [[&quot;bar&quot;,&quot;foo&quot;], [&quot;foo&quot;,&quot;bar&quot;]]
moized(&quot;foo&quot;, &quot;bar&quot;);</code></pre><p><strong>NOTE</strong>: When combined with <code>onCacheChange</code>, this method will always fire first.</p>
<h4 id="oncachechange">onCacheChange</h4>
<p>Method to fire when an item has been either added to cache, or existing cache was reordered based on a cache hit. Receives the cache, options, and memoized function as a parameters.</p>
<pre class="prettyprint source lang-javascript"><code>const fn = (foo, bar) => {
  return [foo, bar];
};

const moized = moize(fn, {
  onCacheChange(cache, options, moized) {
    console.log(cache.keys);
  }
});

moized(&quot;foo&quot;, &quot;bar&quot;); // [[&quot;foo&quot;,&quot;bar&quot;]]
moized(&quot;foo&quot;, &quot;bar&quot;);
moized(&quot;bar&quot;, &quot;foo&quot;); // [[&quot;bar&quot;,&quot;foo&quot;], [&quot;foo&quot;,&quot;bar&quot;]]
moized(&quot;foo&quot;, &quot;bar&quot;); // [[&quot;foo&quot;,&quot;bar&quot;], [&quot;bar&quot;,&quot;foo&quot;]]</code></pre><p><strong>NOTE</strong>: When combined with <code>onCacheAdd</code> or <code>onCacheHit</code>, this method will always fire last.</p>
<h4 id="oncachehit">onCacheHit</h4>
<p>Method to fire when an existing cache item is found. Receives the cache, options, and memoized function as a parameters.</p>
<pre class="prettyprint source lang-javascript"><code>const fn = (foo, bar) => {
  return [foo, bar];
};

const moized = moize(fn, {
  onCacheHit(cache, options, moized) {
    console.log(cache.keys);
  }
});

moized(&quot;foo&quot;, &quot;bar&quot;);
moized(&quot;foo&quot;, &quot;bar&quot;); // [[&quot;foo&quot;,&quot;bar&quot;]]
moized(&quot;bar&quot;, &quot;foo&quot;);
moized(&quot;foo&quot;, &quot;bar&quot;); // [[&quot;bar&quot;,&quot;foo&quot;], [&quot;foo&quot;,&quot;bar&quot;]]</code></pre><p><strong>NOTE</strong>: When combined with <code>onCacheChange</code>, this method will always fire first.</p>
<h4 id="onexpire">onExpire</h4>
<p>A callback that is called when the cached entry expires.</p>
<pre class="prettyprint source lang-javascript"><code>const fn = item => {
  return item;
};

const memoized = moize(fn, {
  maxAge: 10000,
  onExpire(key) {
    console.log(key);
  }
});</code></pre><p>If you return <code>false</code> from this method, it will prevent the key's removal and refresh the expiration in the same vein as <code>updateExpire</code> based on <code>maxAge</code>:</p>
<pre class="prettyprint source lang-javascript"><code>const fn = item => {
  return item;
};

let expirationAttempts = 0;

const memoized = moize(fn, {
  maxAge: 1000 * 10, // 10 seconds
  onExpire(key) {
    expirationAttempts++;

    return expirationAttempts &lt; 2;
  }
});

memoized(&quot;foo&quot;); // will expire key after 30 seconds, or 3 expiration attempts</code></pre><p><strong>NOTE</strong>: You must set a <a href="#maxage"><code>maxAge</code></a> for this option to take effect.</p>
<h4 id="profilename">profileName</h4>
<p><em>defaults to function name and file/line location</em></p>
<p>Name to use as unique identifier for the function when collecting statistics.</p>
<pre class="prettyprint source lang-javascript"><code>collectStats();

const fn = item => {
  return item;
};

const memoized = moize(fn, {
  profileName: &quot;my fancy identity&quot;
});</code></pre><p><strong>NOTE</strong>: You must be collecting statistics for this option to take effect.</p>
<h4 id="shouldserializefunctions">shouldSerializeFunctions</h4>
<p><em>defaults to false</em></p>
<p>A <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">custom replacer</a> is used when serializing to ensure functions are included in the key serialization.</p>
<pre class="prettyprint source lang-javascript"><code>const FunctionalComponent = ({ onClickFoo }) => {
  return (
    &lt;button onClick={onClickFoo} type=&quot;button&quot;>
      Click me!
    &lt;/button>
  );
};

const MemoizedFunctionalComponent = moize(FunctionalComponent, {
  isSerialized: true,
  shouldSerializeFunctions: true
});</code></pre><p><strong>NOTE</strong>: You must set <a href="#isserialized"><code>isSerialized</code></a> for this option to take effect.</p>
<h4 id="serializer">serializer</h4>
<p><em>defaults to serializeArguments in utils.js</em></p>
<p>Method used in place of the internal serializer when serializing the parameters for cache key comparison. The function accepts a single argument, the <code>Array</code> of <code>args</code>, and must also return an <code>Array</code>.</p>
<pre class="prettyprint source lang-javascript"><code>const serializer = args => {
  return [JSON.stringify(args[0])];
};

const memoized = moize(fn, {
  isSerialized: true,
  serializer
});</code></pre><p><strong>NOTE</strong>: You must set <a href="#isserialized"><code>isSerialized</code></a> for this option to take effect.</p>
<h4 id="transformargs">transformArgs</h4>
<p>Transform the arguments passed before it is used as a key. The function accepts a single argument, the <code>Array</code> of <code>args</code>, and must also return an <code>Array</code>.</p>
<pre class="prettyprint source lang-javascript"><code>const fn = (one, two, three) => {
  return [two, three];
};

const ignoreFirstArg = args => {
  return args.slice(1);
};

const moized = moize(fn, {
  transformArgs: ignoreFirstArg
});

moize(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;);
moize(null, &quot;bar&quot;, &quot;baz&quot;); // pulled from cache</code></pre><p>If <code>transformArgs</code> is combined with either <code>maxArgs</code> or <code>serialize</code>, the following order is used:</p>
<ol>
<li>limit by <code>maxArgs</code> (if applicable)</li>
<li>transform by <code>transformArgs</code></li>
<li>serialize by <code>serializer</code> (if applicable)</li>
</ol>
<h4 id="updateexpire">updateExpire</h4>
<p>When a <code>maxAge</code> is set, clear the scheduled expiration of the key when that key is retrieved, setting a new expiration based on the most recent retrieval from cache.</p>
<pre class="prettyprint source lang-javascript"><code>const fn = item => {
  return item;
};

const memoized = moize(fn, {
  maxAge: 1000 * 60 * 5, // five minutes
  updateExpire: true
});

memoized(&quot;foo&quot;);

setTimeout(() => {
  memoized(&quot;foo&quot;); // hits cache, which updates the expire to be 5 minutes from this run instead of the first
}, 1000 * 60);</code></pre><h2 id="usage-with-shortcut-methods">Usage with shortcut methods</h2>
<h4 id="moize-deep">moize.deep</h4>
<p>Pre-applies the <code>isDeepEqual</code> option.</p>
<pre class="prettyprint source lang-javascript"><code>import moize from &quot;moize&quot;;

const foo = (bar, baz) => {
  return `${bar} ${baz}`;
};

export default moize.deep(foo);</code></pre><h4 id="moize-maxage">moize.maxAge</h4>
<p>Pre-applies the <code>maxAge</code> option as a curriable method.</p>
<pre class="prettyprint source lang-javascript"><code>import moize from &quot;moize&quot;;

const foo = (bar, baz) => {
  return `${bar} ${baz}`;
};

export default moize.maxAge(5000)(foo);</code></pre><h4 id="moize-maxargs">moize.maxArgs</h4>
<p>Pre-applies the <code>maxArgs</code> option as a curriable method.</p>
<pre class="prettyprint source lang-javascript"><code>import moize from &quot;moize&quot;;

const foo = (bar, baz) => {
  return `${bar} ${baz}`;
};

export default moize.maxArgs(1)(foo);</code></pre><h4 id="moize-maxsize">moize.maxSize</h4>
<p>Pre-applies the <code>maxSize</code> option as a curriable method.</p>
<pre class="prettyprint source lang-javascript"><code>import moize from &quot;moize&quot;;

const foo = (bar, baz) => {
  return `${bar} ${baz}`;
};

export default moize.maxSize(5)(foo);</code></pre><h4 id="moize-promise">moize.promise</h4>
<p>Pre-applies the <code>isPromise</code> and <code>updateExpire</code> options. The <code>updateExpire</code> option does nothing if <code>maxAge</code> is not also applied, but ensures that the expiration begins at the resolution of the promise rather than the instantiation of it.</p>
<pre class="prettyprint source lang-javascript"><code>import moize from &quot;moize&quot;;

const foo = async (bar, baz) => {
  return await someApiCall(bar, baz);
};

export default moize.promise(foo);</code></pre><p><strong>NOTE</strong>: If you do not want the promise to update its expiration when the cache is hit, then you should use the <code>isPromise</code> option directly instead.</p>
<h4 id="moize-react">moize.react</h4>
<p>Shortcut for memoizing functional components in <a href="https://github.com/facebook/react">React</a>. Key comparisons are based on a shallow equal comparison of both props and context.</p>
<pre class="prettyprint source lang-javascript"><code>import moize from &quot;moize&quot;;

const Foo = ({ bar, baz }) => {
  return (
    &lt;div>
      {bar} {baz}
    &lt;/div>
  );
};

export default moize.react(Foo);</code></pre><p><strong>NOTE</strong>: This method will not operate with components made via the <code>class</code> instantiation, as they do not offer the same <a href="https://en.wikipedia.org/wiki/Referential_transparency">referential transparency</a>.</p>
<p><strong>TIP</strong>: In usages that involve a lot of variety in the parameter changes, this has the potential for excessive memory consumption, as the cache will retain the history of all elements. It is therefore recommended to apply a <code>maxSize</code>, or to use the shortcut method <a href="#moizereactsimple"><code>moize.reactSimple</code></a>, which automatically sets the <code>maxSize</code> to <code>1</code>.</p>
<h4 id="moize-reactsimple">moize.reactSimple</h4>
<p>Shortcut for memoizing functional components in <a href="https://github.com/facebook/react">React</a>, with the cache size limited to a single entry.</p>
<pre class="prettyprint source lang-javascript"><code>import moize from &quot;moize&quot;;

const Foo = ({ bar, baz }) => {
  return (
    &lt;div>
      {bar} {baz}
    &lt;/div>
  );
};

export default moize.reactSimple(Foo);</code></pre><p><strong>NOTE</strong>: This method will not operate with components made via the <code>class</code> instantiation, as they do not offer the same <a href="https://en.wikipedia.org/wiki/Referential_transparency">referential transparency</a>.</p>
<h4 id="moize-serialize">moize.serialize</h4>
<p>Pre-applies the <code>serialize</code> option.</p>
<pre class="prettyprint source lang-javascript"><code>import moize from &quot;moize&quot;;

const foo = (bar, baz) => {
  return `${bar} ${baz}`;
};

export default moize.serialize(foo);</code></pre><p>Please note that if you want to apply <code>shouldSerializeFunctions</code> or provide a custom <code>serializer</code>, you must do so with additional options:</p>
<pre class="prettyprint source lang-javascript"><code>moize.serialize({ shouldSerializeFunctions: true })(fn);</code></pre><h4 id="moize-simple">moize.simple</h4>
<p>Pre-applies the <code>maxSize</code> option with <code>1</code>.</p>
<pre class="prettyprint source lang-javascript"><code>import moize from &quot;moize&quot;;

const foo = (bar, baz) => {
  return `${bar} ${baz}`;
};

export default moize.simple(foo);</code></pre><h2 id="composition">Composition</h2>
<p>Starting with version <code>2.3.0</code>, you can compose <code>moize</code> methods. This will create a new memoized method with the original function that shallowly merges the options of the two setups. Example:</p>
<pre class="prettyprint source lang-javascript"><code>import moize from &quot;moize&quot;;

const Foo = props => {
  return &lt;div {...props} />;
};

// memoizing with react, as since 2.0.0
const MemoizedFoo = moize.react(Foo);

// creating a separately-memoized method that has maxSize of 5
const LastFiveFoo = moize.maxSize(5)(MemoizedFoo);</code></pre><p>You can also create an options-first curriable version of <code>moize</code> if you only pass the options:</p>
<pre class="prettyprint source lang-javascript"><code>import moize from &quot;moize&quot;;

// creates a function that will memoize what is passed
const limitedSerializedMoize = moize({
  maxSize: 5,
  serialize: true
});

const foo = bird => {
  return `${bird} is the word`;
};

const moizedFoo = limitedSerializedMoize(foo);</code></pre><p>You can also combine all of these options with <code>moize.compose</code> to create <code>moize</code> wrappers with pre-defined options.</p>
<pre class="prettyprint source lang-javascript"><code>import moize from &quot;moize&quot;;

// creates a moizer that will have the options of
// {isReact: true, maxAge: 5000, maxSize: 5}
const superLimitedReactMoize = moize.compose(
  moize.react,
  moize.maxSize(5),
  moize.maxAge(5000)
);</code></pre><h2 id="collecting-statistics">Collecting statistics</h2>
<p>As-of version 5, you can collect statistics of moize to determine if your cached methods are effective.</p>
<pre class="prettyprint source lang-javascript"><code>import moize, { collectStats } from &quot;moize&quot;;

collectStats();

const fn = (foo, bar) => {
  return [foo, bar];
};
const moized = moize(fn);

moized(&quot;foo&quot;, &quot;bar&quot;);
moized(&quot;foo&quot;, &quot;bar&quot;);

moized.getStats(); // {&quot;calls&quot;: 2, &quot;hits&quot;: 1, &quot;usage&quot;: &quot;50%&quot;}</code></pre><p><strong>NOTE</strong>: It is recommended not to activate this in production, as it will have a performance decrease.</p>
<h2 id="introspection">Introspection</h2>
<h4 id="collectstats">collectStats</h4>
<p>Start collecting statistics on <code>moize</code>d functions. The same function as if you were to import <code>collectStats</code> directly and call it, just placed on the default object as a convenience.</p>
<pre class="prettyprint source lang-javascript"><code>moize.collectStats();</code></pre><h4 id="getstats-profilename-">getStats([profileName])</h4>
<p>Get the statistics for a specific function, or globally.</p>
<pre class="prettyprint source lang-javascript"><code>collectStats();

const fn = (foo, bar) => {
  return [foo, bar];
};
const moized = moize(fn);

const otherFn = bar => {
  return bar.slice(0, 1);
};
const otherMoized = moize(otherFn, { profileName: &quot;otherMoized&quot; });

moized(&quot;foo&quot;, &quot;bar&quot;);
moized(&quot;foo&quot;, &quot;bar&quot;);

moized.getStats(); // {&quot;calls&quot;: 2, &quot;hits&quot;: 1, &quot;usage&quot;: &quot;50%&quot;}

otherMoized([&quot;baz&quot;]);

moize.getStats(&quot;otherMoized&quot;); // {&quot;calls&quot;: 1, &quot;hits&quot;: 0, &quot;usage&quot;: &quot;0%&quot;}

moize.getStats();
/*
 {
   &quot;calls&quot;: 3,
   &quot;hits&quot;: 1,
   &quot;profiles&quot;: {
     &quot;fn at Object..src/utils.js (http://localhost:3000/app.js:153:68)&quot;: {
       &quot;calls&quot;: 2,
       &quot;hits&quot;: 1,
       &quot;usage&quot;: &quot;50%&quot;
     },
     &quot;otherMoized&quot;: {
       &quot;calls&quot;: 1,
       &quot;hits&quot;: 0,
       &quot;usage&quot;: &quot;0%&quot;
     }
   },
   &quot;usage&quot;: &quot;33.3333%&quot;
 }
 */</code></pre><h4 id="iscollectingstats">isCollectingStats</h4>
<p>Are statistics being collected on memoization usage.</p>
<pre class="prettyprint source lang-javascript"><code>moize.isCollectingStats(); // false

collectStats();

moize.isCollectingStats(); // true</code></pre><h4 id="ismoized">isMoized</h4>
<p>Is the function passed a moized function.</p>
<pre class="prettyprint source lang-javascript"><code>const fn = () => {};
const moizedFn = moize(fn);

moize.isMoized(fn); // false
moize.isMoized(moizedFn); // true</code></pre><h2 id="direct-cache-manipulation">Direct cache manipulation</h2>
<p>The cache is available on the <code>moize</code>d function as a property, and while it is not recommended to modify it directly, that option is available for edge cases.</p>
<h4 id="cache">cache</h4>
<p>The shape of the <code>cache</code> is as follows:</p>
<pre class="prettyprint source lang-javascript"><code>{
  keys: Array&lt;Array&lt;any>>,
  size: number,
  values: Array&lt;any>
}</code></pre><p>Regardless of how the key is transformed, it is always stored as an array (if the value returned is not an array, it is coalesced to one).</p>
<p><strong>NOTE</strong>: The order of <code>keys</code> and <code>values</code> should always align, so be aware when manually manipulating the cache that you need to manually keep in sync any changes to those arrays.</p>
<h4 id="cachesnapshot">cacheSnapshot</h4>
<p>The <code>cache</code> is mutated internally for performance reasons, so logging out the cache at a specific step in the workflow may not give you the information you need. As such, to help with debugging you can request the <code>cacheSnapshot</code>, which has the same shape as the <code>cache</code> but is a shallow clone of each property for persistence.</p>
<p>There are also convenience methods provided on the <code>moize</code>d function which allow for programmatic manipulation of the cache.</p>
<h4 id="add-key-value-">add(key, value)</h4>
<p>This will manually add the <em>value</em> at <em>key</em> in cache if <em>key</em> does not already exist. <em>key</em> should be an <code>Array</code> of values, meant to reflect the arguments passed to the method.</p>
<pre class="prettyprint source lang-javascript"><code>// single parameter is straightforward
const memoized = moize(item => {
  return item;
});

memoized.add([&quot;foo&quot;], &quot;bar&quot;);

// pulls from cache
memoized(&quot;foo&quot;);</code></pre><p><strong>NOTE</strong>: This will only add <code>key</code>s that do not exist in the cache, and will do nothing if the <code>key</code> already exists. If you want to update keys that already exist, use <a href="#updatekey-value"><code>update</code></a>.</p>
<h4 id="clear-">clear()</h4>
<p>This will clear all values in the cache, resetting it to an empty state.</p>
<pre class="prettyprint source lang-javascript"><code>const memoized = moize(item => {
  return item;
});

memoized.clear();</code></pre><h4 id="get-key-">get(key)</h4>
<p>Returns the value in cache if the key matches, else returns <code>undefined</code>. <em>key</em> should be an <code>Array</code> of values, meant to reflect the arguments passed to the method.</p>
<pre class="prettyprint source lang-javascript"><code>const memoized = moize((first, second) => {
  return [first, second];
});

memoized(&quot;foo&quot;, &quot;bar&quot;);

console.log(memoized.get([&quot;foo&quot;, &quot;bar&quot;])); // [&quot;foo&quot;,&quot;bar&quot;]
console.log(memoized.get([&quot;bar&quot;, &quot;baz&quot;])); // undefined</code></pre><h4 id="getstats-">getStats()</h4>
<p>Returns the statistics for the function.</p>
<pre class="prettyprint source lang-javascript"><code>collectStats();

const memoized = moize((first, second) => {
  return [first, second];
});

memoized(&quot;foo&quot;, &quot;bar&quot;);
memoized(&quot;foo&quot;, &quot;bar&quot;);

console.log(memoized.getStats()); // {&quot;calls&quot;: 2, &quot;hits&quot;: 1, &quot;usage&quot;: &quot;50%&quot;}</code></pre><p><strong>NOTE</strong>: You must be collecting statistics for this to be populated.</p>
<h4 id="has-key-">has(key)</h4>
<p>This will return <code>true</code> if a cache entry exists for the <em>key</em> passed, else will return <code>false</code>. <em>key</em> should be an <code>Array</code> of values, meant to reflect the arguments passed to the method.</p>
<pre class="prettyprint source lang-javascript"><code>const memoized = moize((first, second) => {
  return [first, second];
});

memoized(&quot;foo&quot;, &quot;bar&quot;);

console.log(memoized.has([&quot;foo&quot;, &quot;bar&quot;])); // true
console.log(memoized.has([&quot;bar&quot;, &quot;baz&quot;])); // false</code></pre><h4 id="keys-">keys()</h4>
<p>This will return a list of the current keys in <code>cache</code>.</p>
<pre class="prettyprint source lang-javascript"><code>const memoized = moize(item => {
  return item;
});

const foo = &quot;foo&quot;;

memoized(foo);

const bar = {
  baz: &quot;baz&quot;
};

memoized(bar);

const keys = memoized.keys(); // [['foo'], [{baz: 'baz'}]]</code></pre><h4 id="remove-key-">remove(key)</h4>
<p>This will remove the provided <em>key</em> from cache. <em>key</em> should be an <code>Array</code> of values, meant to reflect the arguments passed to the method.</p>
<pre class="prettyprint source lang-javascript"><code>const memoized = moize(item => {
  return item;
});

const foo = {
  bar: &quot;baz&quot;
};

memoized(foo);

memoized.remove([foo]);

// will re-execute, as it is no longer in cache
memoized(foo);</code></pre><p><strong>NOTE</strong>: This will only remove <code>key</code>s that exist in the cache, and will do nothing if the <code>key</code> does not exist.</p>
<h4 id="update-key-value-">update(key, value)</h4>
<p>This will manually update the <em>value</em> at <em>key</em> in cache if <em>key</em> exists. <em>key</em> should be an <code>Array</code> of values, meant to reflect the arguments passed to the method.</p>
<pre class="prettyprint source lang-javascript"><code>// single parameter is straightforward
const memoized = moize(item => {
  return item;
});

memoized.add([&quot;foo&quot;], &quot;bar&quot;);

// pulls from cache
memoized(&quot;foo&quot;);</code></pre><p><strong>NOTE</strong>: This will only update <code>key</code>s that exist in the cache, and will do nothing if the <code>key</code> does not exist. If you want to add keys that do not already exist, use <a href="#addkey-value"><code>add</code></a>.</p>
<h4 id="values-">values()</h4>
<p>This will return a list of the current values in <code>cache</code>.</p>
<pre class="prettyprint source lang-javascript"><code>const memoized = moize(item => {
  return {
    item
  };
});

const foo = &quot;foo&quot;;

memoized(foo);

const bar = {
  baz: &quot;baz&quot;
};

memoized(bar);

const values = memoized.values(); // [{item: 'foo'}, {item: {baz: 'baz'}}]</code></pre><h2 id="benchmarks">Benchmarks</h2>
<p>All values provided are the number of operations per second calculated by the <a href="https://benchmarkjs.com/">Benchmark suite</a>, where a higher value is better. Each benchmark was performed using the default configuration of the library, with a fibonacci calculation based on a starting parameter of <code>35</code>, using single and multiple parameters with different object types. The results were averaged to determine overall speed across possible usage.</p>
<p><strong>NOTE</strong>: <code>lodash</code>, <code>ramda</code>, and <code>underscore</code> do not support mulitple-parameter memoization without use of a <code>resolver</code> function. For consistency in comparison, each use the same <code>resolver</code> that returns the result of <code>JSON.stringify</code> on the arguments.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Overall (average)</th>
<th>Single (average)</th>
<th>Multiple (average)</th>
<th>single primitive</th>
<th>single array</th>
<th>single object</th>
<th>multiple primitive</th>
<th>multiple array</th>
<th>multiple object</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>moize</strong></td>
<td><strong>54,174,185</strong></td>
<td><strong>63,114,600</strong></td>
<td><strong>45,233,770</strong></td>
<td><strong>71,543,826</strong></td>
<td><strong>58,764,177</strong></td>
<td><strong>59,035,797</strong></td>
<td><strong>59,035,797</strong></td>
<td><strong>44,978,364</strong></td>
<td><strong>45,017,968</strong></td>
</tr>
<tr>
<td>fast-memoize</td>
<td>37,591,552</td>
<td>74,183,948</td>
<td>999,155</td>
<td>219,504,451</td>
<td>1,582,247</td>
<td>1,465,147</td>
<td>1,210,230</td>
<td>972,741</td>
<td>814,496</td>
</tr>
<tr>
<td>memoizee</td>
<td>10,953,206</td>
<td>13,429,670</td>
<td>8,476,743</td>
<td>16,114,807</td>
<td>12,226,505</td>
<td>11,947,699</td>
<td>10,238,867</td>
<td>7,615,024</td>
<td>7,576,339</td>
</tr>
<tr>
<td>lodash</td>
<td>7,760,981</td>
<td>14,392,042</td>
<td>1,129,921</td>
<td>27,195,493</td>
<td>8,059,276</td>
<td>7,921,357</td>
<td>1,396,024</td>
<td>1,106,101</td>
<td>887,640</td>
</tr>
<tr>
<td>lru-memoize</td>
<td>6,818,881</td>
<td>7,216,322</td>
<td>6,421,440</td>
<td>7,761,636</td>
<td>7,016,605</td>
<td>6,870,726</td>
<td>6,472,962</td>
<td>6,323,183</td>
<td>6,468,176</td>
</tr>
<tr>
<td>underscore</td>
<td>5,140,473</td>
<td>9,073,217</td>
<td>1,207,730</td>
<td>22,750,266</td>
<td>2,419,458</td>
<td>2,049,928</td>
<td>1,490,129</td>
<td>1,181,751</td>
<td>951,310</td>
</tr>
<tr>
<td>memoizerific</td>
<td>4,320,437</td>
<td>4,784,512</td>
<td>3,856,362</td>
<td>5,608,168</td>
<td>4,374,440</td>
<td>4,370,928</td>
<td>4,568,332</td>
<td>3,455,887</td>
<td>3,544,867</td>
</tr>
<tr>
<td>ramda</td>
<td>3,831,370</td>
<td>6,470,175</td>
<td>1,192,564</td>
<td>15,012,589</td>
<td>2,380,971</td>
<td>2,016,966</td>
<td>1,470,378</td>
<td>1,161,390</td>
<td>945,926</td>
</tr>
<tr>
<td>mem</td>
<td>2,679,860</td>
<td>4,138,450</td>
<td>1,221,271</td>
<td>9,431,005</td>
<td>1,554,267</td>
<td>1,430,078</td>
<td>1,537,629</td>
<td>1,197,269</td>
<td>928,915</td>
</tr>
<tr>
<td>addy-osmani</td>
<td>2,504,948</td>
<td>3,224,227</td>
<td>1,785,669</td>
<td>6,430,710</td>
<td>1,560,466</td>
<td>1,681,506</td>
<td>3,215,093</td>
<td>1,184,364</td>
<td>957,550</td>
</tr>
</tbody>
</table>
<p><img src="img/overall-average.png" alt="Overall average image"></p>
<p><img src="img/single-parameter.png" alt="Single parameter image"></p>
<p><img src="img/multiple-parameters.png" alt="Multiple parameters image"></p>
<h2 id="filesize">Filesize</h2>
<p><code>moize</code> is fairly small (about 4.5KB when minified and gzipped), however it provides a large number of configuration options to satisfy a number of edge cases. If filesize is a concern, you may consider using <a href="https://github.com/planttheidea/micro-memoize"><code>micro-memoize</code></a>. This is the memoization library that powers <code>moize</code> under-the-hood, and will handle most common use cases at 1/4 the size of <code>moize</code>.</p>
<h2 id="browser-support">Browser support</h2>
<ul>
<li>Chrome (all versions)</li>
<li>Firefox (all versions)</li>
<li>Edge (all versions)</li>
<li>Opera 15+</li>
<li>IE 9+</li>
<li>Safari 6+</li>
<li>iOS 8+</li>
<li>Android 4+</li>
</ul>
<h2 id="development">Development</h2>
<p>Standard stuff, clone the repo and <code>npm install</code> dependencies. The npm scripts available:</p>
<ul>
<li><code>benchmark</code> =&gt; run the benchmark suite pitting <code>moize</code> against other libraries in common use-cases</li>
<li><code>benchmark:alternative</code> =&gt; run the benchmark suite for alternative forms of caching in <code>moize</code></li>
<li><code>build</code> =&gt; run rollup to build the distributed files in <code>dist</code></li>
<li><code>clean</code> =&gt; run <code>clean:lib</code>, <code>clean:es</code>, <code>clean:dist</code>, and <code>clean:docs</code></li>
<li><code>clean:dist</code> =&gt; run <code>rimraf</code> on the <code>dist</code> folder</li>
<li><code>clean:docs</code> =&gt; run <code>rimraf</code> on the <code>docs</code> folder</li>
<li><code>clean:es</code> =&gt; run <code>rimraf</code> on the <code>es</code> folder</li>
<li><code>clean:lib</code> =&gt; run <code>rimraf</code> on the <code>lib</code> folder</li>
<li><code>dev</code> =&gt; run webpack dev server to run example app (playground!)</li>
<li><code>dist</code> =&gt; runs <code>clean:dist</code> and <code>build</code></li>
<li><code>docs</code> =&gt; runs <code>clean:docs</code> and builds the docs via <code>jsdoc</code></li>
<li><code>flow</code> =&gt; runs <code>flow check</code> on the files in <code>src</code></li>
<li><code>lint</code> =&gt; runs ESLint against all files in the <code>src</code> folder</li>
<li><code>lint:fix</code> =&gt; runs <code>lint`</code>, fixing any errors if possible</li>
<li><code>postpublish</code> =&gt; runs <code>docs</code></li>
<li><code>prepublish</code> =&gt; runs <code>compile-for-publish</code></li>
<li><code>prepublish:compile</code> =&gt; run <code>lint</code>, <code>flow</code>, <code>test:coverage</code>, <code>transpile:lib</code>, <code>transpile:es</code>, and <code>dist</code></li>
<li><code>test</code> =&gt; run AVA test functions with <code>NODE_ENV=test</code></li>
<li><code>test:coverage</code> =&gt; run <code>test</code> but with <code>nyc</code> for coverage checker</li>
<li><code>test:watch</code> =&gt; run <code>test</code>, but with persistent watcher</li>
<li><code>transpile:es</code> =&gt; run babel against all files in <code>src</code> to create files in <code>es</code>, preserving ES2015 modules (for <a href="https://github.com/rollup/rollup/wiki/pkg.module"><code>pkg.module</code></a>)</li>
<li><code>transpile:lib</code> =&gt; run babel against all files in <code>src</code> to create files in <code>lib</code></li>
</ul></article>
    </section>







		</div>
	</div>

	<div class="clearfix"></div>

	
		<div class="col-md-3">
			<div id="toc" class="col-md-3 hidden-xs hidden-sm hidden-md"></div>
		</div>
	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a>
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->

<script>
	$( function () {
		$( '#main' ).localScroll( {
			offset : { top : 60 } //offset by the height of your header (give or take a few px, see what works for you)
		} );
		$( "dt.name" ).each( function () {
			var $this = $( this ).find("h4");
			var icon = $( "<i/>" ).addClass( "icon-plus-sign" ).addClass( "pull-right" ).addClass( "icon-white" );
			var dt = $(this);
			var children = dt.next( "dd" );

			dt.prepend( icon ).css( {cursor : "pointer"} );
			dt.addClass( "member-collapsed" ).addClass( "member" );


			children.hide();

			dt.children().on( "click", function () {
				children = dt.next( "dd" );
				children.slideToggle( "fast", function () {

					if ( children.is( ":visible" ) ) {
						icon.addClass( "icon-minus-sign" ).removeClass( "icon-plus-sign" ).removeClass( "icon-white" );
						dt.addClass( "member-open" ).animate( "member-collapsed" );
					} else {
						icon.addClass( "icon-plus-sign" ).removeClass( "icon-minus-sign" ).addClass( "icon-white" );
						dt.addClass( "member-collapsed" ).removeClass( "member-open" );
					}
				} );
			} );

		} );
	} );
</script>


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>